[TOC]

# 数据抽象
内部的实现（内部数据或方法）不应当暴露出来，只将外部使用的部分暴露。

类不应该直接将变量放出去，而应该暴露抽象接口，以便用户无需了解数据的实现即可操作数据本体。

联系下一节，作者的意思是类内部数据的相关处理交给类本身进行处理，而不是将数据暴露出去，在外面进行处理。

# 数据、对象的反对称性
举一个将类暴露出去，在外部处理数据的做法（过程式）：
```ts
type Point = [number,number];

class Square {
    public topLeft ?: Point;
    public side:number = 100;
}

class Rectangle{
    public topLeft ?: Point;
    public width:number = 100;
    public height:number = 20;
}

class Circle{
    public center ?: Point;
    public radius:number = 100;
}

class Geometry{
    public PI:number = 3.1415926;

    public area(shape:object):number | never{
        if(shape instanceof Square){
            return shape.side * shape.side;
        }
        if(shape instanceof Rectangle){
            return shape.width * shape.height;
        }
        if(shape instanceof Circle){
            return this.PI * shape.radius * shape.radius;
        }
        throw new Error("没有这种形状！")
    }
}
```
关注这份代码，如果我们要添加一个统一的新方法，那么只需要修改公共类，不需要修改形状类。<br/>
另一方面，如果我们想要添加一个新的形状，则需要修改公共类中的所有方法。<br/>
这两种情形是直接对立的，使用多态式的写法，添加一个新方法需要修改所有形状类，而添加一个新的形状，只需要增加一个形状类，不会影响到其他类。

在类的内部进行相关处理的做法（多态式）：
```ts
type Point = [number,number];

class Square {
    private topLeft ?: Point;
    private side:number = 100;

    public area():number{
        return this.side * this.side;
    }
}

class Rectangle{
    private topLeft ?: Point;
    private width:number = 100;
    private height:number = 20;

    public area():number{
        return this.width * this.height;
    }
}

class Circle{
    private center ?: Point;
    private radius:number = 100;
    private PI:number = 3.1415926;

    public area():number{
        return this.PI * this.radius * this.radius
    }
}
```
这里再次体现了对象与数据结构之间的二分原理：<br/>
过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数；面向对象代码便于在不改动既有函数的前提下添加新类。

这里也可以换一种说法：<br/>
过程式代码难以添加新数据结构，因为必须修改所有函数；面向对象代码难以添加新函数，因为必须修改所有类。

## 小结
对象暴露行为、隐藏数据，便于添加新对象类型，难以添加新行为。

数据结构暴露数据，没有明显的行为，便于添加新的行为，**难以添加新的类型**

开发过程中，如果希望灵活添加新数据类型，那么使用对象和多态更合适；如果希望灵活添加新行为，则使用数据类型和过程更合适。

# 得墨忒耳定律
也被称作最小知识原则，是一种软件开发的设计指导原则，特别是面向对象的程序设计。得墨忒耳定律是松耦合的一种具体案例。
- 每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元；
- 每个单元只能和它的朋友交谈：不能和陌生单元交谈；
- 只和自己直接的朋友交谈。

这个原理的名称来源于希腊神话中的农业之神，孤独的得墨忒耳。这个定律也被称作迪米特法则，因为得墨忒耳的拉丁语就是`Demeter`.

优点：得墨忒耳定律使得软件更好的可维护性与适应性。因为对象较少依赖其它对象的内部结构，可以改变对象容器（container）而不用改变它的调用者（caller）。

得墨忒耳定律认为，类C的方法f只应该调用以下对象的方法：
1. C
2. 由f创建的对象
3. 作为参数传递给f的对象
4. 由C的实体变量持有的对象
   
换言之：**不应该调用由任何函数返回的对象的方法**
> 但是得墨忒耳定律第二条是允许调用由f创建的对象的方法的啊，这是怎么回事？

## 火车失事
下面是一个违反得墨忒耳定律的示例：
```js
const outputDir = ctx.getOptions().getScratchDir().getAbsolutePath();
```
这种写法被称作火车失事，因为它看起来就像是一列火车，这类连串的调用通常被认为是肮脏的风格，应该避免，最好做类型以下的切分：
> 但实际上链式调用感觉更舒爽，重构里是提倡链式写法的，这里需要更细致的思辨
```js
const opts = ctx.getOptions();
const scratchDir = opts.getScratchDir();
const outputDir = scratchDir.getAbsolutePath();
```
当然，即使是改成这种写法，依旧违反得墨忒耳定律。
//...

## 混杂

## 隐藏结构

# 数据传送对象

# 豆知识
## 得墨忒耳
得墨忒耳为什么孤独？希腊神话中说到孤独我一开始会想到的是象征自由与独立的女神-狩猎与月之女神阿尔忒弥斯。<br/>

后来稍微了解了一下，阿尔忒弥斯的确象征着自由与独立，但是她本身并不孤独，她父亲是众神之主宙斯，母亲是泰坦女神托勒，弟弟是同为奥林匹斯十二主神之一的太阳神阿波罗。同父异母的兄弟姐妹比如雅典娜、阿瑞斯之类的太多。<br/>

得墨忒耳是第四世代神，为十二提坦神神王克诺洛斯与神后瑞亚所生的第二个女儿，是众神之主宙斯、众神之母赫拉、海王波塞冬、冥王哈迪斯的姐姐，其本身也位列奥林匹斯最高位，是奥林匹斯十二主神之一。<br/>

得墨忒耳和宙斯有私生女名为珀耳塞福涅，珀耳塞福涅从小就和母亲得墨忒耳在一起生活，并且从未考虑过婚配之事。有一次珀耳塞福涅在丛林中与宁芙仙女们游玩时，大地突然裂开，冥王哈迪斯趁机把她给劫走了，哈迪斯早已爱上了之女珀耳塞福涅，在宙斯的默许和帮助下才实行了此次计划。<br/>

被劫的珀耳塞福涅悲哀地呼喊着母亲，得墨忒耳听到了珀耳塞福涅的呼救声，心如刀绞，她赶忙放下手中的农活，朝着呼喊声奔去，但此时珀耳塞福涅早已不见了踪影。得墨忒耳焦急万分，她连续几天几夜不吃不喝，四处寻找女儿的下落。就这样，得墨忒耳一连九天九夜走遍天涯海角也毫无所获。当第十天来临之际，她偶然间遇到了赫卡忒，她也听到了珀耳塞福涅的呼救声，只是没认出行抢的人。

## 希腊神话时代
第0世代：
卡俄斯（chaos 混沌），宇宙形成前的一片混沌，无象无形，不可描述。最初最古之神

第1世代：
卡俄斯的产物，包括：
1. 盖亚（大地）
2. 塔耳塔罗斯（大地底层）
3. 厄洛斯（欲望）
4. 倪克斯（黑夜）
5. 厄瑞玻斯（黑暗）

第2世代：
1. 埃忒耳（光明）-倪克斯和厄瑞玻斯所生
2. 赫墨拉（白天）-倪克斯和厄瑞玻斯所生
3. 乌拉诺斯（天空）-盖亚独生
4. 蓬托斯（海洋）-盖亚独生

第3世代：
> 主要是十二提坦神-盖亚与乌拉诺斯所生
1. 克罗诺斯（神王）-男-主司时间
2. 瑞亚（天后）-女-大神母（地母神）
3. 俄刻阿诺斯-男-河神，一切河流之父
4. 许珀里翁-男-东方与光明之神
5. 克利奥斯-男-南方与星辰之神
6. 科俄斯-男-北方与黑暗之神
7. 伊阿珀托斯-男-西方与言论之神
8. 谟涅摩叙涅-女-记忆，缪斯之母
9. 福柏-女-无明确主司，传统上认为与月球有关
10. 忒亚-女-无明确主司，太阳神、月亮女神、黎明女神之母
11. 忒弥斯-女-土地，主司法律与正义
12. 特堤斯-女-所有海神的祖母，沧海女神

第4世代：
1. 宙斯（神王）

## 相关资料
- [得墨忒耳定律-维基](https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B)
- [得墨忒耳-维基](https://zh.wikipedia.org/wiki/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3)
- [迪米特法则-百度](https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99)