[TOC]

 # 类的组织
 Java的代码位置约定：
 1. 公共静态常量
 2. 私有静态变量
 3. 私有实体变量
 4. 公共变量【基本没有】
 5. 公共函数
 6. 私有工具函数

 ## 封装
 我们优先保证变量和函数的私有性，但并不执着于此。
 
 如果有时候测试需要用到私有变量和工具函数，那么以测试优先。

 记住：保证隐私，放松封装是危险的。

 # 类应该短小
类有两条规则：短小、更短小！

函数我们通过行数衡量大小，类要通过什么方式衡量大小？——权责

类的大小不通过方法数量进行衡量。

命名——是判断类职责的第一手段。如果我们不能为某个类精确命名，那么这个类很可能职责过大，如果出现了含糊的词语，比如`Manager`、`Processeor`、`Super`等，这往往意味着权责聚集的情况存在。

可以用2-5个单词简要进行描述，且不使用if、and、or、but等词语是比较理想的。

 ## 单一权责原则`SRP`
 每个类应该只有一个功能，罗伯特·C·马丁将功能(职责)定义为：“改变的原因”，一个类或一个模块应该有且只有一个改变的原因。
 > 但是这个并不好界定...

 ## 内聚
 类应该只有少量实体变量，类中的每一个方法都应该操作一个或多个这种变量。

类中的方法和变量依赖越高，其内聚性越高

 ## 保持内聚性就会得到许多短小的类
 将大类拆成小类，将大函数拆成小函数，就可以得到更加内聚的函数或类，一个函数或类越大，便难以做到内聚。

 以下是从`knuth`的名著`literate Programming`中拿出的一个例子，是`PrintPrimes`的Java版本，它可以很好的体现如何将大函数拆解成小函数和类。<br/>
 `PrintPrimes.java`
 ```java
 package literatePrimes;

 public class PrintPrimes(){
     public static void main(String[] args){
         final int M = 1000;
         final int RR = 50;
         final int CC = 4;
         final int WW = 10;
         final int ORDMAX = 30;
         int P[] = new int[M + 1];
         int PAGENUMBER;
         int PAGEOFFSET;
         int ROWOFFSET;
         int C;
         int J;
         int K;
         boolean JPRIME;
         int ORD;
         int SQUARE;
         int N;
         int MULT[] = new int[ORDMAX + 1];

         J = 1;
         K = 1;
         P[1] = 2;
         ORD = 2;
         SQUARE = 9;

         while(k < M){
             do{
                 J = J + 2;
                 if(J == SQUARE){
                     ORD = ORD + 1;
                     SQUARE = P[ORD] * P[ORD];
                     MULT[ORD - 1] = J;
                 }
                 N = 2;
                 JPRIME = true;
                 while(N < ORD && JPRIME){
                     while(MULT[N] < J)
                        MULT[N] = MULT[N] + P[N] + P[N];
                     if（MULT[N] == J)
                        JPRIME = false;
                     N = N + 1;
                 }
             } while (!JPRIME);
             K = K + 1;
             P[K] = J;
         }

         
         {
             PAGENUMBER = 1;
             PAGEOFFSET = 1;
             while(PAGEOFFSET <= M){
                 System.out.println("The First " + M + " Prime Numbers --- Page " + PAGENUMBER);
                 System.out.println("");
                 for (ROWOFFSET = PAGEOFFSET; ROWOFFSET < PAGEOFFSET + PR; ROWOFFSET++){
                     for (C = 0; C < CC; C++)
                        if (ROWOFFSET + C * RR <= M)
                            System.out.format("%10d",P[ROWOFFSET + C * RR]);
                     System.out.println("");
                 }
                 System.out.println("\f");
                 PAGENUMBER = PAGENUMBER + 1;
                 PAGEOFFSET = PAGEOFFSET + RR * CC;
             }
         }
     }
 }
 ```

 将这个类重构为三个小类。<br/>
 `PrimePrinter.java`
 ```java
 package literatePrimes;

 public class PrimePrinter{
     public static void main(String[] args){
         final int NUMBER_OF_PRIMES = 1000;
         int [] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);

         final int ROW_PER_PAGE = 50;
         final int COLUMNS_PRE_PAGE = 4;
         RowColumnPagePrinter tabPrinter = 
            new RowColumnPagePrinter(ROW_PER_PAGE,
                                     COLUMNS_PRE_PAGE,
                                     "The First " + NUMBER_OF_PRIMES + " Prime Numbers");
         tablePrinter.print(primes);
     }
 }
 ```

 `RowColumnPagePrinter.java`
 ```java
 package literatePrimes;
 
 import java.io.PrintStream;

 public class RowColumnPagePrinter {
     private int rowsPerPage;
     private int columnsPerPage;
     private int numbersPerPage;
     private String PageHeader;
     private PrintStream printStream;

     public RowColumnsPagePrinter(int rowsPerPage,
                                  int columnsPerPage,
                                  String pageHeader){
        this.rowsPerPage = rowsPerPage;
        this.columnsPerPage = columnsPerPage;
        this.pageHeader = pageHeader;
        numbersPerPage = rowPerPage * columnsPerPage;
        printStream = System.out;
     }

     public void print(int data[]){
         int pageNumber = 1;
         for (int firstIndexOnPage = 0;
              firstIndexOnPage < data.length;
              firstIndexOnPage += numberPerPage){
            int lastIndexOnPage = 
                Math.min(firstIndexOnPage + numbersPerPage - 1,
                         data.length - 1);
            printPageHeader(pageHeader,pageNumber);
            printPage(firstIndexOnPage,lastIndexOnPage,data);
            printStream.println("\f");
            pageNumber++;
         } 
     }

     private void printPage(int firstIndexOnPage,
                            int lastIndexOnPage,
                            int[] data){
        int firstIndexOfOnPage = 
            firstIndexOnPage + rowsPerPage - 1;
        for (int firstIndexInRow = firstIndeOnPage;
             firstIndexInRow <= firstIndexOfLastRowOnPage;
             firstIndexInRow++) {
            printRow(firstIndexInRow, lastIndexOnPage,data);
            printStream.println("");
        }
    }

    private void printRow(int firstIndexInRow,
                          int lastIndexOnPage,
                          int[] data){
        for (int columns = 0; column < columnsPerPage; columns++) {
            int index = firstIndexInPage + columns * rowsPerPage;
            if (index <= lastIndexOnPage)
                printStream.format("%10d",data[index]);
        }
    }

    private void printPageHeader(String pageHeader,
                                 int pageNumber){
        printStream.println(pageHeader + " --- Page " + pageNumer);
        printStream.println("");
    }

    private void setOutput(PrintStream printStream) {
        this.printStream = printStream;
    }
 }
 ```

 `PrimeGenerator.java`
 ```java
 package literaterPrimes;

 import java.util.ArrayList;

 public class PrimeGenerator {
     private static int[] primes;
     private static ArrayList<Interger> muliplesOfPrimeFactors;

     protected static int[] generate (int n) {
         primes = new int[n];
         multiplesOfPrimeFactors = new ArrayList<Interger>();
         set2AsFirstPrime();
         checkOddNumbersForSubsequentPrimes();
         return primes;
     }

     private static void set2AsFirstPrimes() {
        primes[0] = 2;
        multiplesOfPrimeFactors.add(2);
     }

     private static void checkOddNumbersForSubsequentPrimes() {
         int primeIndex = 1;
         for (int candidate = 3;
              primeIndex < primes.length;
              candidate += 2) {
            if (isPrime(candidate))
                primes[primeIndex++] = candidate;
         }
     }

     private static boolean isPrime(int candidate){
         if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
             multiplesOfPrimeFactors.add(condidate);
             return false;
         }
         return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
     }

     private static boolean
     isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
         int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
         int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
         return candidate == leastRelevantMultiple;
     }

     private static boolean
     isNotMultipleOfAnyPreviousPrimeFactor(int candidate){
         for (int n = 1; n< multiplesOfPrimeFactors.size(); n++) {
             if(isMultipleOfNthPrimeFactor(candidate, n))
                return false;
         }
         return true;
     }

     private static boolean
     isMultipleOfNthPrimeFactor(int candidate, int n) {
         return 
            candidate == samllestOddNthMultipleNotLessThanCandidate(candidate, n);
     }

     private static int
     samllestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
         int multiple = mutiplesOfPrimeFactors.get(n);
         while (multple < candidate)
            multiple += 2 * primes[n];
         multplesOfPrimeFactors.set(n, multiple);
         return multiple;
     }
 }
 ```

 # 为了修改而组织
