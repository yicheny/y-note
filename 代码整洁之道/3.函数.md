[TOC]

# 好函数特征
## 1. 短小
编程的第一原则是短小，第二原则是更短小。

20世纪80年代，Bob大叔他们的原则是函数不该长于一屏，那个时候VT100屏幕有24行、80列，编辑器占用4行放菜单。

到了现在，我们使用小字体和大屏幕，100行、150列不是问题，但即使如此一行也不要有150字符，函数也不该有100行那么长，20行封顶最佳。

1991，bob大叔去找kent beck，发现他写的小程序里函数只有两三行、三四行。每个函数一目了然，每个函数只说一件事，每个函数都依序将读者带到下一个函数，这就是函数应该达到的短小程度。

### 代码块与缩进
`if/else`、`while`语句的代码应该只占一行，这一行应该是一个函数调用语句，这样不仅能保持函数的短小，而且，因为块内调用的函数拥有较具说明性名称，所以也增加了文档上的价值。

函数不应该大到足以容纳嵌套结构，函数的缩进层级不应该多于一层或两层，这样的函数易于阅读和理解。

## 2. 只做一件事
判断一个函数是否不止做了一件事，就是看它能否再拆出一个函数，如果拆除的函数只是单纯的重新诠释其实现，没有改变其抽象层级，则还是在做相同的事情。

## 3. 每个函数一个抽象层级
要确保函数只做一件事，函数的语句就要放到同一抽象层级上。

函数中混杂不同抽象层级，往往会让人迷惑，读者可能无法判断某个表达式是基础概念还是细节。

### 自顶向下读代码：向下规则
我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样在查看函数列表时，就能循抽象层级向下阅读了。

## 4. switch
> 注：if/else也有一样的问题
switch很难写的简短，除非它只做一件事，然而switch天生需要做很多事情。

switch存在的问题：
1. 代码太长
2. 做了不止一件事
3. 违反单一权责原则，有好几个修改它的理由
4. 违反开放闭合原则，每当添加新类型时，就必须修改switch

## 5. 使用具有描述性的名称

## 6. 函数参数
最理想的参数数量是0，其次是1，再次是2，应尽量避免3，有足够特殊的理由才能用三个以上的参数——所以无论如何也不要这么做！

参数会带来哪些麻烦：
1. 带有太多概念性，参数和函数名处于不同抽象层级，它要求我们了解目前并不特别重要的细节
2. 从测试角度来说，参数越多越麻烦，因为多参数的组合是非常多种的，需要足够多的案例进行覆盖 
3. 输出参数比输入参数更让人难以理解。一般来说，我们习惯会认为信息通过参数输入函数，通过返回值从函数中输出，我们不会期望信息通过参数输出，输出参数往往让人迷惑

### 6.1 单参数
//待补充

### 6.2 标识参数
标识参数丑陋不堪，向函数传入布尔值标识（或者类型标识）简直是骇人听闻的做法，这么做，方法签名会立刻变得复杂起来，相当于大声宣布这个函数不只做一件事，即如果标识为true这么做，标识为false那样做。

比如：
```js
render(true);//render(isSuite);
//重构后
renderForSuite();
renderForStringTest();
```

### 6.3 双参数
- 双参数比单参数难懂
  - 忽略
  - 琢磨
  - 排序，并没有明确的排序规则

如果是单个值的有序组成部分，那么就不要拆分成多个参数

有一些手段可以帮助我们将双参数转换为单参数

### 6.4 三参数函数
三参数比双参数要复杂很多倍。排序、琢磨、忽略的问题会加倍体现

### 6.5 参数对象
具有多个参数时，说明我们将其中一部分封装成类。比如说:
```js
makeCircle(x,y,radius);
makeCircle(center,radius);
```
从参数创建对象，从而减少参数数量，看起来像是作弊，但实则并非如此。当一组参数倍共同传递，就像上例中的x和y那样，它们是某个概念的一部分，这个概念本身就起着解释参数的作用

### 6.6 参数列表
有时我们需要传入数量可变的参数

### 6.7 动词与关键字
函数名可以用于解释函数的意图，参数的顺序和意图。

对于单参数函数，函数和参数应当形成一种良好的动词/名词形式。比如说`write(name)`

我们可以将参数的名称编码到函数名称中，`assertExpectedEqualActual(expected,actual)`，比如这种就将大大减轻记忆参数顺序的负担。

## 7. 无副作用
> 但是书里并没有说怎么解决副作用

副作用是一种谎言。我们承诺函数只做一件事，副作用的存在违反了这个承诺。

副作用是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。

即使我们可以将副作用编码到名称中，但依旧违反了只做一件事原则

### 输出参数
一般我们会默认将参数当作输入值，所以最好不要将参数作为输出值。

`appendFooter(s)`，这里的参数s是输入值还是输出值？它是将s添加到什么值的后面吗？还是将什么东西添加到了s后面？

我们可以花一点时间看看函数签名，`appendFooter(report)`,现在我们清楚s是输出值了，但是被迫付出了时间的代价，并且打断了自己的思路，这是要避免的。

在面向对象编程中，输出参数的大部分需求已经消失了，我们会这么用：`report.append()`。

## 8. 分隔指令和查询
函数要么去什么事，要么回答什么事，二者不可得兼，如果两件事都做，就是一个混乱的函数

## 9. 使用异常代替错误码
在指令式函数中使用错误码略微违反了指令与询问分隔的规则，它鼓励了在if中将指令码当作表达式使用

这种做法会导致更深层次的嵌套，如果使用异常替代返回错误码，错误处理代码就可以从核心代码中分离出来，从而得到简化。

- 抽取`try/catch`代码块
  - 以`try`开头
  - `catch/finally`后不要处理其他
- 错误处理就是一件事
- 错误处理是一个独立的抽象层级
- 错误码会产生**依赖磁铁**的问题，一旦修改会影响到所有使用的地方。（使用异常替代错误码，新异常就可以从异常类派生出来，不需要修改所有场景）

## 10.别重复自己
有些重复很容易抽取出来，有些则麻烦一些，一些重复可能和其他代码混在一起，而且而并不完全一样——这种重复更加可怕一些，代码会因此越发臃肿，使得阅读和理解变得困难。

抽离重复有哪些好处？
1. **修改方便**，只需要修改一处
2. **减少犯错的可能**。很多时候我们改一个问题，在一处代码可能要修改多次，然而因为代码并不完全相同，我们并不能简单的复制粘贴，这意味着我们需要进行多次的复杂修改，而每一次修改都可能犯错或遗漏修改。

抽取重复的一些手法：
- 函数、类、组件等【hook是特殊的函数】
- 柯里化
- 设计模式

## 11. 结构化编程
[结构化编程-维基百科](https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B)

结构化编程（英语：Structured programming），一种编程典范。它采用子程序、块结构、for循环以及while循环等结构，来取代传统的 goto。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。

## 12. 如何写出好的函数-重构
第一次以优先实现功能为主，冗长、重复、丑陋都不是问题，好的函数在于后期重构与打磨。

想要做好重构，单元测试是必要的，每次修改都要保证测试通过。