没有显式传递参数的函数对其参数的控制要更精准，比如在这么一个业务场景下：
```
convert:Dateformat;//(v,o,i)=>Dateformat(v,o,i);
```

这种写法会出问题，问题的关键不在于调用，而在于`Dateformat`的定义，它是这么定义的：
```js
export function Dateformat(patten, fmt = 'day') {
    const reDate14 = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$/;
    const reDate8 = /^([0-9]{4})([0-9]{2})([0-9]{2})$/;
    if (!patten) return ''

    patten = patten + '';
    if ([8, 14].includes(patten.length)) {
        let year, month, day, hour, min, sec;
        if (reDate14.test(patten)) {
            const match = reDate14.exec(patten);
            [year, month, day, hour, min, sec] = match.slice(1, Infinity);
        }
        if (reDate8.test(patten)) {
            const match = reDate8.exec(patten);
            [year, month, day] = match.slice(1, Infinity);;
        }

        let fmtobj = {
            'year': year,
            'month': `${year}-${month}`,
            'day': `${year}-${month}-${day}`,
            'hr': `${year}-${month}-${day} ${hour}:${min}:${sec}`,
            'week': `${year}-${_week_number(new Date(_.toSafeInteger(year), _.toSafeInteger(month) - 1, _.toSafeInteger(day)))}周`
        }
        return fmtobj[fmt];
    }
}
```

问题在于什么地方？<br/>
这种写法没有控制好第二个参数，默认如果我们什么都不传，则内部调用的是`day`模式。<br/>
`Dateformat(x)`等同于`Dateformat(x,'day')`，实际上是有问题的，我们希望的是，如果形参`fmt`传递的参数是`year`、`month`、`hr`、`week`之外的时候，返回的都是`day`模式的值。

修改版本1：
```js
export function Dateformat(patten, fmt) {
    const reDate14 = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$/;
    const reDate8 = /^([0-9]{4})([0-9]{2})([0-9]{2})$/;
    if (!patten) return ''

    patten = patten + '';
    if ([8, 14].includes(patten.length)) {
        let year, month, day, hour, min, sec;
        if (reDate14.test(patten)) {
            const match = reDate14.exec(patten);
            [year, month, day, hour, min, sec] = match.slice(1, Infinity);
        }
        if (reDate8.test(patten)) {
            const match = reDate8.exec(patten);
            [year, month, day] = match.slice(1, Infinity);;
        }

        let fmtobj = {
            'year': year,
            'month': `${year}-${month}`,
            'hr': `${year}-${month}-${day} ${hour}:${min}:${sec}`,
            'week': `${year}-${_week_number(new Date(_.toSafeInteger(year), _.toSafeInteger(month) - 1, _.toSafeInteger(day)))}周`
        }
        return fmtobj[fmt] || ${year}-${month}-${day};
    }
}
```

不过即便如此修改，我也不认为这是一种特别好的做法，因为某些情况下，第二个参数也可能因为意外而恰好传入符合模式的字符串，这是有可能的。

我认为更好的做法是将各个模式给独立出来【类似`number_format`和`N0`、`N2`这样】：

修改版本2：
```js
function getDateformatInfo(patten) {
    const reDate14 = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$/;
    const reDate8 = /^([0-9]{4})([0-9]{2})([0-9]{2})$/;
    if (!patten) return null;

    patten = patten + '';
    if ([8, 14].includes(patten.length)) {
        let year, month, day, hour, min, sec;
        if (reDate14.test(patten)) {
            const match = reDate14.exec(patten);
            [year, month, day, hour, min, sec] = match.slice(1, Infinity);
        }
        if (reDate8.test(patten)) {
            const match = reDate8.exec(patten);
            [year, month, day] = match.slice(1, Infinity);;
        }
        return {year, month, day, hour, min, sec};
    }

    return null;
}

function year_DateFormate(patten){
    const info = getDateFormatInfo(patten);
    if(_.isNull(info)) return '-';
    const {year} = info;
    return year;
}

function month_DateFormate(patten){
    const info = getDateFormatInfo(patten);
    if(_.isNull(info)) return '-';
    const {year,month} = info;
    return `${year}-${month}`;
}

function day_DateFormate(patten){
    const info = getDateFormatInfo(patten);
    if(_.isNull(info)) return '-';
    const {year,month,day} = info;
    return `${year}-${month}-${day}`;
}

function hr_DateFormate(patten){
    const info = getDateFormatInfo(patten);
    if(_.isNull(info)) return '-';
    const {year,month,day,hour,min,sec} = info;
    return `${year}-${month}-${day} ${hour}:${min}:${sec}`;
}

function week_DateFormate(patten){
    const info = getDateFormatInfo(patten);
    if(_.isNull(info)) return '-';
    const {year,month,day} = info;
    return `${year}-${_week_number(new Date(_.toSafeInteger(year), _.toSafeInteger(month) - 1, _.toSafeInteger(day)))}周`;
}
```
我们将`fmt`除去，得到不同的5个函数，函数内部不再进行判断，函数职责变得更加纯粹。
我们更加需要调用不同的函数，如此一来，无论外部如何调用，对我们来说都是安全的，而且外部的参数改变，我们也可以在不同的函数内进行调整，而不需要进行改动。
不过即使如此，目前这种写法还是有一些问题：
1. 存在一部分重复的逻辑【怎么消除？】
2. 这里的5个函数，都是大范围复用的函数，使用场景可能很多，参数改变对存在两种情况【比如`year_DateFormat`】
    1. 真的所有涉及`year_DateFormat`的参数都改变了，那么可以通过`year_DateFormat`进行全局性调整
    2. 局部参数调整了，如果原需求不变，对我们来说函数依旧是安全的，如果一部分需要改变，那么对于改变的地方进行替换函数即可

对比一下原来的写法：
1. 假设部分调用的参数变化，需求不变，这种写法更加安全
2. 假设参数变化，部分需求也变化，这种情况下差不多，实际上也是修改后的方案更优，因为调用处的替换可能步骤相差无几，然而因为需求上的修改，我们需要对原函数进行改动。<br/>
函数`DateFormat`同时承担着5种场景的处理，代码更难理解，职责更大，需要测试和保证的安全范围更大，可以想象一下，假设所有项目中5种情况各使用了200次，一共使用了1000次，那么针对某一场景的需求变化，如果分隔开我们只需要测试200次，但是使用原写法它需求进行的测试却是1000次。<br/>
实际5种模式的使用频率可能并不一相同，改动也不需要进行这么多次的测试。但是难以否认的是，前一种写法不同场景的变量处于相同的作用域，一旦修改其影响的范围要大于后一种。<br/>
而后一种做法将相同的处理过程给独立成函数进行复用，将不同的分支处理分割成不同的函数，并不是1/5，而是(1/2)/5，其粒度更精细，影响的范围更小，也更容易理解，我们可以更好的进行控制和修改，它具有更好的可读性、可维护性以及健壮性。