[TOC]

# 3.4 可靠传输原理

## 3.4.1 构造可靠数据传输协议

### `rdt1.0`:经完全可靠信道的可靠数据传输
这是最简单的场景，这种场景下发送方和接受方只有两种状态：
- 发送方：等待、发送
- 接收方：等待、接受

这种场景下没有需要解决的问题

### `rdt2.0`:经具有比特差错信道的可靠数据传输
首先明确以下几点：
1. 分组会出错
1. 不会丢包
1. 保证顺序发送和接收是一致

我们现在需要关注的问题是：
- 如果分组出错了怎么处理？
- 怎么检测分组出错

这里用一个例子来说明下：假设每个分组都是一句话，比如：“你好，我是小明”，接收方收到分组后，如果可以理解，那么就回复`ok`（**肯定确认 ACK**），如果不理解就回复`please repeat`（**否定确认 NAK**），发送方接收到NAK则将该分组重传一份。

可以看到这个过程需要三种协议的支持：
1. 差错检查
2. 接收方反馈
3. 重传

#### 状态
发送方可能的状态：
1. 等待调用
1. 发送中
   1. 等待ACK或NAK
1. 重传 

接收方可能的状态：
1. 等待调用
1. 接收中
   1. 发送ACK或NAK

接收方依旧只有两种状态，接收方与之前相比多了一种状态：重传

#### 流程
现在的传输流程是这样的：
1. 发送端发送分组到接收端，等待反馈
2. 接收端接收数据
   1. 正常，返回ACK
   2. 异常，返回ACK
3. 发送端接收反馈
   1. ACK，发送下一分组
   2. NAK，重传
4. 重复上述过程，直到传输完所有分组

值得注意的是，目前我们的传输协议可以被称作**停等协议**，目前在传输完成当前分组前是不会接收新的调用命令传递分组的，也就是说只能一个一个的进行分组传输。这种方式的传输效率无疑是很低的

#### 问题
ACK、NAK分组的数据出现差错。【这里同样不考虑丢包的问题】

##### ACK、NAK受损
首先考虑受损的情况【不考虑分组丢失】，现在提供三种方案并评估其优劣性：
1. 如果受损，发送端发送一条信息：“你说什么，请重述一遍”，接收端接收到这条信息则重复发送一次之前的命令。不过会有一个麻烦的问题：如果这条信息出错了接收端会难以确认这条受损信息是指示重复的命令还是需要接收的数据。
1. 增加足够的检验和比特，使发送方不仅可以检查差错，还可以恢复差错，对于产生差错但不丢失分组的情况可以解决。【不过如果用于检验和恢复差错的信息出错怎么办？】
1. 收到受损命令时，重传当前分组即可。这种方案会产生**冗余分组**，就是接收方不能确定这条信息是旧分组还是新的分组。

解决了分组受损的协议我们将之称为`rdt2.1`

我们现在使用第三种，对于其产生的冗余分组我们的方案是“添加序号”，现在我们是停等协议，所以只需要一个比特就可以解决问题，比如用0表示新分组，1表示重传分组。

解决冗余分组的协议我们将之称为`rdt2.2`

### `rdt3.0`：经具有比特差错的丢包信道的可靠数据传输
需要关注2个问题：
1. 怎么检测丢包？
1. 丢包之后怎么处理？

#### 检测丢包
有两种情况我们认为发生丢包：
1. 分组丢失
1. 接收方发送的ACK丢失

一个直接的想法是：发送方等待**足够长**的时间以便确定分组丢失。

关键就在于“足够长”，多长的时间才算足够长？

发送方至少需要等待：
1. 往返传输时间
1. 往返传输时延
1. 接收方处理分组的时间

在这三种时间中，最麻烦的是时延，最坏场景下的最大时延是很难估算的，即便可以估算，还是会有一个麻烦的问题，就是等待时间会很长，可能是一个我们无法接收的时间值。

基于以上分析，实践中采取的方案是发送方决定一个时间值，以判定可能发生了丢包

#### 解决方案
如果这个选定时间值内没有收到ACK，则重传该分组。

重传会造成冗余分组的问题，不过所幸我们已经在`rdt2.2`中解决过相同的问题。

##### 倒计数定时器
想要实现基于时间的重传功能，我们需要一个倒计数定时器