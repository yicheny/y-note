[TOC]

备注：之所以没有第二节，因为第二节变量声明完全是ES原生知识，直接略过

# 介绍
TS核心原则之一：**对值所具有的结构进行类型检查**<br>
这种做法也被叫做“鸭式辨型法”或“结构性子类型化”

在TS中，接口的作用是为这些类型命名和为开发者【自己或第三方】的代码定义契约

```typescript
//注意：这里没有使用接口，会报错
function printLabel(labelledObj:{label:string}) {
    console.log(labelledObj.label);      
}

let myObj = {size:10,label:"Size 10 Object"};
printLabel(myObj);
```

使用接口的正确写法：
```typescript
interface LabelledValue {
    label: string;
}

function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```
类型检查器不会去检查属性的属性，只要相应的属性存在并且类型也是对的就可以

# 可选属性
```typescript
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
console.log(mySquare);
```
可选属性的好处有两个：
1. 可以对可能存在的属性进行预定义
2. 可以捕获引用了不存在的属性时的错误

# 只读属性
## 方式一：`readonly`
```typescript
interface Point {
  readonly x:number,
  readonly y:number
}

const p1:Point = {x:10,y:20};
p1.x = 5;//error
```

## 方式二：`ReadonlyArray<T>`
> 用法和`Array<T>`类似

```typescript
const a:number[] = [1,2,3,4];
let b:ReadonlyArray<number> = a;
b[0] = 12;//error
b.push(5);//error
b.length = 10;//error
a = b;//error
```

## `readonly` 和 `const`
最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用`readonly`。

# 额外的属性检查
通过接口定义的属性可以不传，接口没定义的属性不可以传。<br/>
换句话说：可以少传，不可多传
```typescript
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

const square1 = createSquare({color: "black"});
const square2 = createSquare({color: 'red',opacity:0.5});//error
```

## 传额外属性的方案
### 方案一：使用类型断言
```typescript
let square = createSquare({width:100,opacity:0.5} as SquareConfig);
``` 

### 方案二：添加字符串索引签名
```typescript
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;//这表示SquareConfig可以有任意数量的属性，只要它们不是color和width，那么它是什么类型都可以
}
```

### 方案三：将对象赋值给一个变量
```typescript
const squareOption = {color:'red',opacity:0.4};
const square = createSquare(squareOption);
```

# 函数类型
使用接口表示函数类型，需要给接口定义一个调用签名，签名定义了参数列表和返回值类型，参数列表定义了每个参数的名称和类型

```typescript
//函数类型定义
interface SearchFunc {
  (source:string,subString:string):boolean;
}

//函数接口使用
let mySearch:SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}
```

# 可索引的类型
和使用接口描述函数类型类似，可以使用接口描述“通过索引得到”的类型，比如`a[10]`或`o[age]`

```typescript
interface StringArray {
    [index:number]: string;
}

const array1:StringArray = ["Bob",'Fred'];
console.log(array1);
// const array2:StringArray = [1,2];//error
```

ts支持两种索引签名：字符串和数字，可以同时使用两种类型的索引，但是**数字索引的返回值必须是字符串索引返回值类型的子类型**<br/>
这是因为使用`number`索引时，js会将其转换成`string`再去索引，因此两者必须保持一致
> 建议不同同时使用两种类型的索引

```typescript
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
```

```typescript
interface NumberDictionary {
  [index: string]: number;//这里限定了所有索引的类型
  length: number;    
  name: string       // error
}
```
同样的，索引签名可以设置为只读

# 类类型
## 实现接口
接口描述了类的公共部分，但是它不会检查类是否有其他组成部分
```typescript
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```

## 类静态部分与实例部分的区别
类具有两个类型：静态部分的类型和实例的类型。

`constructor`部分属于静态部分，静态部分不能直接在定义的时候通过构造器进行限制，比如：

```typescript
//error
interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```

原因是一个类实现一个接口时，只对实例部分进行检查，对静态部分是不做检查的。

因此，对于类的静态部分，需要直接操作，见下例：

```typescript
//此接口为实例方法所用
interface ClockInterface {
    tick();
}
//注意ClockConstructor是怎么描述静态部分的
//此接口为构造函数所用
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
```

## 接口继承
一个接口可以继承多个接口

```typescript
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

## 混合类型
一个对象可以具有多种类型，比如可以同时作为对象和函数

```typescript
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

## 接口继承类
当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。
```typescript
class Control {
    private state: any;
}

class Control2 {
    private state: any;
}

class Control3 {
    
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class Button2 extends Control2 implements SelectableControl {
    select() { }
}

//error
class Button3 extends Control3 implements SelectableControl {
    select() { }
}

class Button4 implements SelectableControl{
    private state: any;
    select() { }
}
``` 