[TOC]

# 纯函数定义
纯函数就是相同的输入永远得到相同的输出，且没有可观测的副作用。
> 比如`slice`和`splice`

在函数式编程中我们追求不改变数据的纯函数写法。

纯函数写法，我们应当尽可能减少对外部环境的依赖，比如:
```js
// 不纯的
var minimum = 21;
var checkAge = function(age) {
  return age >= minimum;
};

// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```
我们可以看到，不纯的写法中，它的确没有产生副作用，然而它在内部使用了外部变量，这会产生两点坏处：
1. `minimum`处于外部环境，可以被很多函数访问到，处于外部环境的变量是不能被随意更改的，比如这里，假设有多个同时使用了这个变量，因为业务需求的改变，某函数A使用的此变量需要改为`100`。处于外部环境的`minimum`就不能被随意修改，一旦修改，所有使用此外部状态的函数都会收到影响
> 基于这一点，在外部使用的变量，应该保证其不可变
2. 引入了外部环境，增加了认知负担。考虑一种情况，现在`minimum`变量被多个函数所使用，在某个函数A中因副作用改变了`minimum`的值，使用到`minimum`的函数都被影响了，开发者观测到某个函数B的运行出现了异常，函数B本身是没有副作用的，逻辑也正常。
现在想要修复这个bug就变得复杂了，事情没有那么简单，
    1. 首先开发者可能得花费一段时间才能确认这个函数本身逻辑没有问题，问题出在外部状态。
    2. 如果只有外部状态`minimum`，我们需要查看所有使用到`minimum`的函数，这本身就很麻烦，如果使用 `minimum`的函数都集中在同一个文件中可能场景要简单些，我们在文件中查看所有使用到此状态的函数
    3. 不可避免地，有些内部状态使用了和外部状态同样的名称`minimum`
    4. 极端情况下，声明的变量是个比较通用的名字，那就很恶心了
    5. 如果在多个文件中有函数使用了此变量，那就更加恶心了，全局搜索`minimum`极大可能遇到其他内部变量或外部变量使用此名称，那么我们想找到使用相应外部变量`minimum`的函数都很麻烦。
    6. 以上是只使用一个外部状态的情况，如果函数B使用了多个外部状态呢？复杂度会再加上一个系数。
> 因此引入外部环境是非常危险的，平时可能感觉不到，一旦出现问题，想要追查问题就很恶心了。
3. 移植成本高，难以移植

相比较之下，我们可以看出纯函数的好处：
1. 方便维护。相关状态都在函数内部了，容易看出逻辑上的问题，修改状态也不会影响到其他地方，安全。
2. 方便移植，相关状态都在函数内部了，直接拿走就可以。

除了将相关状态放到函数内部，我们也可以使外部状态不可变，保留其纯粹性。比如:
```js
const minimum = 21;

var immutableState = Object.freeze({
  minimum: 21
});
```

# 副作用
**副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。**

副作用可能包含，但不限于：
- 更改文件系统
- 往数据库插入记录
- 发送一个 http 请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM 查询
- 访问系统状态 <br/>
……

副作用的范围非常宽泛，**只要与函数外部状态发生交互就是副作用**，基于此，无副作用编程几乎是不可能的。不过，我们并不是想禁止使用一切副作用，而是想将副作用控制在一个可变范围内。
> 关于如何控制副作用，请见后面的`functor`和`monad`

为什么说副作用让函数变得不纯？<br/>
纯函数的定义要求相同的输入必须得到相同的输出，一旦函数与外部进行交互，就很难保证这一点了。

# 纯函数的优点
## 可缓存性(Cacheable)
纯函数可以通过输入来做缓存，实现缓存的一种典型技术是`memoize`：
```js
function memoize(f){
  const cache = {}
  return function(){
    const arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || fn.apply(f,argument);
    return cache[arg_str];
  }
}
```
在实例中测试下：
```js
var squareNumber  = memoize(function(x){ return x*x; });

squareNumber(4);
//=> 16

squareNumber(4); // 从缓存中读取输入值为 4 的结果
//=> 16
```

### 可以通过延迟执行将不纯的函数变成纯函数
```js
var pureHttpCall = memoize(function(url, params){
  return function() { return $.getJSON(url, params); }
});
```
这里的关键在于这个函数并没有直接返回结果，而是根据参数返回一个对应的函数，它符合纯函数相同输入总得到相同输出的定义，因而是纯函数。

现在来看这种方式意义不大，不过很快我们就会学习一些技巧来发掘它的用处。重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。

## 可移植性／自文档化（Portable / Self-Documenting）
纯函数是完全自给自足的，它需要的所有东西在函数内部。<br>
仔细思考思考这一点...这种自给自足的好处是什么呢？<br>
首先，纯函数的依赖很明确，因此更易于观察和理解——没有偷偷摸摸的小动作。<br>

```js
// 不纯的
var signUp = function(attrs) {
  var user = saveUser(attrs);
  welcomeUser(user);
};

var saveUser = function(attrs) {
    var user = Db.save(attrs);
    ...
};

var welcomeUser = function(user) {
    Email(user, ...);
    ...
};

// 纯的
var signUp = function(Db, Email, attrs) {
  return function() {
    var user = saveUser(Db, attrs);
    welcomeUser(Email, user);
  };
};

var saveUser = function(Db, attrs) {
    ...
};

var welcomeUser = function(Email, user) {
    ...
};
```
这里纯函数与非纯函数的区别在于：纯函数所用到的外部状态都通过参数函数，如此一来，我们可以很容易观察到它们使用的外部状态。
我们很轻松的得到了一些关键性的信息(我们提倡尽可能地减少参数，不过如果通过参数我们可以获取关键信息，那么这个参数就是值得的)

将外部状态通过参数形式传递(或者说注入依赖)，这种方式有其他一些好处：
1. 灵活，因为参数可配置
2. 可移植，因为外部依赖均通过参数传递

命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与环境无关，只要我们愿意，可以在任何地方运行它。

Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林”。

## 可测试性（Testable）
纯函数让测试变得更简单，因为我们不再关注环境，只需要测试输入输出即可。

## 合理性（Reasonable）
纯函数最大的好处是**引用透明性**（referential transparency）
> 这一点对于重构极为有利

如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。

对于具有引用透明性的函数，我们可以使用一种叫做“等式推导”（equational reasoning）的技术来分析代码。所谓“等式推导”就是“一对一”替换，因为纯函数不关注环境，所以可以大胆的进行替换。

## 并行代码
最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。
> 这一点也减少了bug的出现，在开始的时候也提到了使用外部状态会共享内存，竞态的出现会让代码的分析变得极为困难。

并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。不过出于对非纯函数复杂度的考虑，当前主流观点还是避免使用这种并行。

# 总结
目前介绍了副作用的坏处，以及纯函数可以为我们带来的好处。

到这里，写一些纯函数还是有些麻烦的，我们通过传递很多参数来控制数据，接下来，我们学习使用一种名为`curry`的工具来简化操作