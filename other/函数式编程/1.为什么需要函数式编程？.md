[TOC]

# 开始
文档举了一个鸟群的例子，开始使用类实现，后面使用函数式实现了一个更简洁的写法。

例子不重要，通过这个例子是想告诉我们:在面向对象的写法中，有两个问题：
1. 状态难以跟踪
2. `this`很麻烦，不是说它的指向，而是因为它是动态变化的，有时候这是个好用的特性，有的时候却会造成运算上的错误【当我们需要数据不可变时】

# 一等公民的函数
函数是一等公民的意思是：函数可以和其他类型一样使用，比如可以作为对象属性、数组项、函数参数、函数返回值等……

## 可读性
下面是文档给出的一些场景的糟糕写法：
> 虽然确实很糟糕，不过我没看懂这和函数一等公民有啥关系
```
//糟糕写法
const getServerStuff = callback => ajaxCall(json => callback(json)); //你可以很快看清楚这种写法
吗？这里只套了两层其实还行，三层以上是真的恶心，很难看明白

//推荐写法
const getServerStuff = ajaxCall;
```

所以，日常写法中，可以不套的尽量不要套，影响可读性。

## 可维护
除了可读性之外，另一个考虑的因素是可维护性，见下面这个例子：
```
//原写法
httpGet('/post/2', json => renderPost(json));

//需求修改
httpGet('/post/2', (json, err) => renderPost(json, err));

//如果减少了多余嵌套
httpGet('/post/2', renderPost);
```

使用这种写法好处在于当回调传递的参数改变时，不需要改变调用处的写法，就可以拿到改变后的参数。比如说：
```
//原
renderData:N2 //(a)=>N2(a);

//如果添加参数
renderData:N2 //(a,b)=>N2(a,b);
```
我们可以发现，避免显示传递参数，在减少传递之外，也可以方便的响应改变的参数，我们不需要改变调用处的写法，也可以拿到改变后的参数，有时候是很方便的。

## this
```
var fs = require('fs');

// 太可怕了
fs.readFile('freaky_friday.txt', Db.save);

// 好一点点
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
```
`this`对于函数式写法而言是完全不必要的一个垃圾，如果迫不得已需要使用含`this`的类库，那么使用时需要借助`bind`弥补