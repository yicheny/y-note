[TOC]

```
#include <stdio.h>

int main()
{
    printf("hello world\n");
    return 0;
}
```
请执行以下操作：
1. 将刚刚的那段代码复制并保存到`hello.c`文件中
2. 通过编译器【我用的是Dev-C++】编译成`hello.exe`文件
3. 运行`cmd`程序，输入`hello`命令，按下回车

此时会在屏幕上输出`hello world`信息。

首先分析这个`hello.c`程序的生命周期。<br>
`hello.c`是程序员编写的源程序，它是文本文件，是程序员用于阅读和理解的文字。<br>
这段程序信息是如何保存在计算机中的？这涉及到一个计算机领域的基本思想：**计算机中的一切程序和资料，都是以二进制形式保存的**<br>
`hello.c`的每一个字符都对应着一个整数值，这个整数值被转换成二进制字节保存。
- 什么是字节？由8个位组成的序列
- 什么是位[bit]？计算机存储的最小单位，0或1

# 程序编译
为什么需要编译程序？<br>
类似c语言的高级编程语言所写的源代码人类可以看懂，计算机是不能看懂和执行的。计算机可以执行的代码是低级机器语言，因此需要一种程序将源代码转换成低级机器语言以供计算机执行<br>
进行转换的程序叫做**编译器驱动程序**，它由四个阶段的子程序构成，也可以叫做**编译系统**<br>
经源代码转换得到的文件被叫做*可执行文件*(或*可执行目标文件*)，同样以二进制字节的形式保存在计算机中。

下面着重介绍下编译的四个阶段:
1. **预处理**：`hello.c`=>`hello.i`——将源代码进行预处理，比如头部的`#include <stdio.h>`指示预处理器将`stdio.h`的内容直接插入程序文本以得到一个新的文件`hello.i`
2. **编译**：`hello.i`=>`hello.s`——将`hello.i`文件编译成汇编语言版本`hello.s`
> 汇编语言的意义在于为不同的高级编程语言提供了通用的输出语言
3. **汇编**：`hello.s`=>`hello.o`——将汇编语言转换成二进制机器语言，并将其打包成*可重定位目标程序*
4. **链接**：`hello.o`=>`hello.exe`——在示例代码中使用了`printf`函数，这个函数存在于`printf.o`文件中，这个文件必须和`hello.o`文件合并。这一阶段就负责处理合并，最终得到可执行文件`hello.exe`。可执行文件可以被加载到内存中，由系统执行

## 处理器读并解释存储在内存中的指令
1. 运行`cmd`程序，会输出提示符`_`，等待我们输入指令
2. 输入`hello`，`cmd`程序会先判断这是否是一个内置的`cmd`指令，如果不是则会假设这是一个可执行文件的名字，如果是一个可执行文件，它会加载并运行这个文件，然后等待程序终止
3. `hello`程序输出信息，终止运行。`cmd`程序随后输出提示符`_`，等待新的输入指令

# 硬件组成
## 1. 总线
- 定义：贯穿整个系统的一组电子管道
- 作用：携带信息字节并负责在各个部件间传递
- 细节描述：通常总线被设计成传送定长的字节块，也就是字(word)，字中的字节数（即*字长*）是一个基本的信息参数，在不同系统中不尽相同，目前机器8字节(64位)和4字节(32位)的情况较多

## 2. I/O
I/O设备是计算机与外界交互的通道。<br>
常见的I/O设备包括：键盘、鼠标、显示器、磁盘<br>
I/O设备通过*控制器*或*适配器*与I/O总线相连。
- *控制器*:I/O设备本身或主板上的芯片组
- *适配器*:主板插槽上的卡<br>
两者的作用都是在I/O设备和I/O总线间传递信息

## 3. 主存
- 定义：临时存储设备
- 作用：在处理器执行程序时，存放程序和数据
- 细节描述：变量相对应的数据项大小是根据类型变化的，由C语言举例，在运行linux的x86-64机器上，short类型的数据需要2个字节，init和float类型需要4个字节，而long和double需要8个字节

## 4. 处理器-CPU
中央处理单元，简称处理器。
- 定义：执行存储在主存中指令的引擎
- 细节描述：CPU的核心叫做寄存器，或者程序计数器(PC)，是大小为一个字的存储器。在任何时刻，PC都指向存储在主存中的某条机器语言指令。

### 4.1 CPU执行
在系统通电期间，CPU持续不断的执行PC指向的指令（解释指令中的位，执行该指令指示的简单操作），再更新PC使其指向下一条指令<br>
执行简单操作的核心是：
1. **主存**
2. **寄存器文件**
3. **算数/逻辑单元(ALU)**
> 寄存器文件：是一个存储设备，由寄存器组成，每个寄存器拥有唯一的名字

CPU可能执行的简单操作包括:
1. **加载**：从主存复制一个字节或一个字到寄存器，已覆盖寄存器原来的内容
2. **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容
3. **操作**：将两个寄存器的内容复制到ALU，ALU对两个字做算数运算，并将结果存放到一个寄存器中，以覆盖寄存器中原来的内容
4. **跳转**：从指令本身中抽取一个字，并将这个字复制到寄存器中，已覆盖寄存器中原来的值

- *指令集架构*：描述的是处理器的功能效果
- *微体系结构*：描述的是处理器的具体实现

# 运行hello程序
> 注：所有的信息传递都需要通过总线
1. cmd程序运行，输入`hello`
    - 通过键盘输入信息，信息通过总线传递至寄存器，CPU进行操作将信息复制到显示设备
2. 敲下回车，执行`hello.exe`文件程序，输出`hello world`
    - 键盘输入信息，CPU接受信息后进行操作，将`hello.exe`的信息从磁盘加载至主存，再将信息依次传递给寄存器，CPU执行指令，将信息从寄存器复制到显示设备。
> 其实这里涉及到一个细节，默认将磁盘信息加载至主存，是需要通过CPU操作的，信息路线：磁盘——寄存器——主存<br>
> DMA(直接存储器存取)技术可以跳过CPU直接将信息传递至主存，信息路线：磁盘——主存

从运行hello程序这个例子中，可以发现一件事，在执行程序的过程中，系统大量工作是将信息从一个地方移到另一个地方。

系统设计者有一个重要的目标就是尽可能快的进行这些复制操作。

# 高速缓存
存储设备有一个基本原则：容量、性能、价格三者优势不可共存，通常来说，容量越大速度越慢，反之亦然。

这是影响计算机设计的一个重要因素，并且磁盘、主存、寄存器三者之间的性能随着科技的发展差异还在不断增大。

系统设计者采取了一种叫做**高速缓存**的方案。简单来说就是使用更小更快的设备存放更有可能用到的数据。

一般计算机拥有两级高速缓存设备(L1、L2)，一些性能更强大的拥有三级高速缓存设备(L1、L2、L3)
> 高速缓存是通过SRAM(静态随机访问存储器)硬件技术实现的

# 计算机存储设备介绍
速度由快至慢，容量由小至大：
1. 寄存器
2. L1高速缓存
3. L2
4. L3
5. 主存(DRAM)
6. 本地磁盘
7. 远程存储(分布式文件系统，web服务器)

# 操作系统管理硬件
hello程序运行时并没有直接调用硬件设备，而是依赖于*操作系统*进行硬件操作。<br>
操作系统是什么？是用于操作硬件设备的一系列软件程序。<br>

为什么需要操作系统：
1. 安全，防止应用程序滥用
2. 简单，提供了一套统一而简单的机制用于操作复杂而不同的低级硬件设备。

操作系统如何实现它的两个基本功能？这涉及几个抽象概念：
- **文件**：对I/O设备的抽象表示
- **虚拟内存**：对I/O设备和主存的抽象表示
- **进程**：对I/O设备、主存和CPU的抽象表示

除此之外，还需要计算机中的两个重要的抽象概念：
- **指令集架构**：对CPU的抽象表示
- **虚拟机**：对I/O设备、主存、CPU和操作系统的抽象表示

## 1. 进程
进程是计算机科学中最重要也最成功的概念之一。

进程是对正在运行的程序的一种抽象，一个操作系统可以同时运行多个进程，每个进程都好像在独占的使用硬件。

*并发运行*是指一个进程的指令和另一个进程的指令交替运行。

无论单核还是多核系统，CPU都可以表现得像是同时执行多个进程，这是通过CPU在不同进程间切换实现的，这种交错执行的机制叫做**上下文切换**

**上下文**，指操作系统保持跟踪进程运行所需的所有状态信息。

上下文切换是由操作系统**内核**(kernel)管理的。
> 内核不是一个独立的进程，它是系统管理进程所用代码和数据结构的集合

# 2. 线程
通常认为进程由单一控制流构成，在现代操作系统中，进程可以由多个称作进程的执行单元构成。

进程运行在进程的上下文中，共享全局数据和代码，因此一般情况下线程比进程更高效

# 3. 虚拟内存

# 4. 文件
**文件就是字节序列**。一切I/O设备，包括磁盘、硬盘、显示器，甚至网络都可以被看做文件。

# 网络通信
网络是特殊的I/O设备

# 重要主题
## 1. Amdahl定律
**当对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度**

假设原执行时间为T-old，系统某部分执行时间为总执行时间比例为a，该部分性能提升为k，则：
```
T-new = (1-a)*T-old + (a/k)*T-old
      = ((1-a)+a/k) * T-old

S = T-old / T-new
  = 1 / ((1-a) + a/k)
```

## 2. 并行和并发
- **并发**：一个同时具有多个活动的系统
- **并行**：用并发来使系统运行的更快

### 2.1 线程级并行

### 2.2 指令级并行

### 2.3 单指令、多数据并行【SIMD】