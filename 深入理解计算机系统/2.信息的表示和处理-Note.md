[TOC]

# 重点内容概览
- 信息存储
- 整数
- 浮点数

# 信息存储
- 人有十根手指，对人而言十进制是最原始也最自然的数字表示法。对人而言很简单，对机器却不是，要表示十进制则需要有十种不同的形式或者说变化，对于机器制造而言，它有些麻烦
- 二进制没有这个问题，它最简单，非常适合构造存储和处理信息的机器，任意两种变化就可以表示二进制，比如卡片的有孔无孔、导线的高低电压、磁场的顺逆时针等等...
- 二进制和十进制用于描述字节都不方便，一字节8位，值域是0~255，使用两位十六进制可以极为方便的描述字节。
> 注：二进制转十六进制时，如果其位数不足4的倍数，则向左边补0

## 进制转换
十进制转十六进制：
```
原数：314516 【十进制】

314516 / 16 = 19634 余 12  (C)
19634 / 16 = 1227 余 2     (2)
1227 / 16 = 76 余 11       (B)
76 / 16 = 4 余 12          (C)
4 / 16 = 0 余 4            (4)

十六进制： 0x4CB2C
```


十六转十进制：
```
原数：0x7AF【十六进制】

7*(16^2) + 10*16 + 15 = 1792 + 160 + 15 = 1967

十进制：1967
```

## 字数据大小
每台计算机都有一个**字长**(word size)，虚拟地址是使用这样一个字来编码的，字长决定的最重要的系统参数是虚拟空间地址的最大大小。

虚拟空间的地址是使用无符号表示法表示的，它从0开始，直到最大值为止。对于一个字长为w位的机器而言，地址范围就是0 ~ (2^w -1)，程序最多可以访问2^w个字节
> 32字节限制虚拟空间地址为4千兆字节(4GB)，超过4 * 10^9字节<br/>
> 64字节限制虚拟空间地址为16EB，约1.84 * 10^19字节

## 寻址和字节顺序
有些程序对象是跨越一个字节的，对于跨越多字节的程序对象，有两个规则需要明确：
1. 这个对象的地址是什么？
2. 在内存中如何排列这些字节？

**在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象地址为所使用字节的最小地址**

比如，地址表达式`&x`的地址为`0x100`，假设这个值的类型为`int`，那么表示x的4个字节将会被存储在`0x100`、`0x101`、`0x102`、`0x103`地址

现在有一个w位的整数，其位表示为[w-1、w-2、w-3……2、1、0]，其中`w-1`为最高有效位，`0`为最低有效位。
> 比如现在有一个十进制数`12345`，其最高有效位为万位，最低有效为个位

假设w是8的倍数，这些为可以分组为字节，其最高有效字节是`[w-1、w-2……w-8]`，其最低有效字节是`[7、6……0]`
- **大端法**：内存中按照从最高有效字节到最低有效字节排列【高=>低】
- **小端法**：内存中按照从最低有效字节到最高有效字节排列【低=>高】

范例：假设变量x的类型为`int`，位于地址`0x100`处，它的十六进制值是`0x01234567`，那么它在内存的存储可能是：
```
地址     0x100    0x101    0x102    0x103
大端法   01       23       45       67
小端法   67       45       23       01
```

**双端法**
现在比较新的微处理器支持双端法，可以自主将其配置成大端或小端法，不过大小端通常和系统挂定，一旦选择相应的操作系统，那么字节顺序也就被固定了。(意思就是硬件可以支持双端操作，但是操作系统只能运行其中一种模式)

一般情况下字节顺序是不可见的，无论是哪种模式其机器编译的程序所得到的结果都是相同的，不过有时候，字节顺序会成为问题。<br>
同一系统下，字节顺序是固定的，所以不会有问题。然而在网络传输二进制数据时，不同机器的字节顺序可能是不同的，此时就会出问题。<br>
为避免网络传输时的问题，网络应用程序的编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换为网络标准，而接收方机器将网络标准转换为它的内部表示。

# 豆知识
## 帕斯卡计算机
机械计算机的时代是1623-1930

标志进入机械计算机时代的是契科卡德计算钟，契科卡德是天文学家开普勒的工作伙伴，出于工作需要，他创造了契科卡德计算钟。
之所以叫做“计算钟”是因为溢出时会发出警告。

可惜的是契科卡德的计算钟被烧毁了，并没有留存实物。

契科卡德计算钟的原理是单齿进位制，如图：![image](https://upload-images.jianshu.io/upload_images/30022-4d33cd91a9fa47c0.gif?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

这种方式有个缺陷，齿轮通过手动转动，同时有多个进位时，旋转起来会非常吃力，有两个问题：
1. 转动需要极大的力量
2. 齿轮承受不住如此巨大的压力，可能断裂

契科卡德计算钟受限于这种齿轮机制，只能进行三位数以下的运算。

1623年(恰好在发明计算钟的同一年)，帕斯卡出生了，他创造了真正意义上的第一代机械计算机——帕斯卡算术机。

1639年，法国三十年战争期间，帕斯卡父亲艾蒂安被任命为鲁昂市税务总管，战时鲁昂税务一片混乱，艾蒂安的工作涉及大量枯燥而繁重的加减计算。

1642年，帕斯卡为缓解父亲工作压力，发明了帕斯卡计算机。

帕斯卡在设计计算机的过程中，遇到了和契科卡德一样的问题，经过无数次尝试，他终于想到了解决连续进位的方法，他设计了一种新的进位装置`sautoir`，如图：
![image](https://upload-images.jianshu.io/upload_images/30022-da149ccea3acadb5.gif?imageMogr2/auto-orient/strip|imageView2/2/w/496/format/webp)

这种装置解决了进位时的压力问题，仅从进位而言，即使进行上万位的连续进位，也可以正常进行。

这种方式确实解决了进位的问题，不过也带来了另外一个缺陷：不能反转。

不能反转意味着想要置零是很麻烦的，需要从个位开始依次将每一位数转到9，而后在个位上加1以产生连续进位，完成所有位的置零。

因为置零上的缺陷，帕斯卡不可能真正设计成数百位上千位的大位计算装置。不过，这并不是真正致命的问题，这的确是个问题，但影响并没有那么大，因为日常运算用不到那么多的运算，帕斯卡计算机已足够位数的需求。

更需要解决的问题是：齿轮不能反转，如何实现减法？

帕斯卡设计出`sautoir`装置已经极其厉害，但更厉害的是他想出了一种用加法代替减法的方案：**补码**

补码方案在现代计算机中依旧沿用，它简单而有用。

十进制下的补码是补九码：对于1位数，0的补码是9，1的补码是8，2的补码是7，以此类推

帕斯卡计算机会同时显示两排数，一排是原数，一排是其对应补码，如图：
![image](https://upload-images.jianshu.io/upload_images/30022-7a9508d8ffe3d1e4.JPG?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

现在假设我们有一台6位的帕斯卡计算机，让我们模拟下它是如何进行减法运算的.
原数：002000
补码：997999
现在为补码加上355，补码997999+355=998354，998354的补码为1645，即为2000-355的差

补码：998354
原数：001645
2000 - 1645 = 355

6位十进制整数的补码值这样运算得到:
> 注：CP是一个用于计算补码的函数，括号内求补码的原值
```
CP(a) = 999999 - a;
```

那么原数a减去减数b，可以用补码这么算：
```
CP(a-b) = 999999 - (a-b)
   = 999999 - a + b
   = CP(a) + b
```

## 原码、反码、补码
现代计算机中，使用ASCII码表示文本字符，数字使用另外的方式保存，如果使用ASCII码存储数字，会造成存储时的浪费，比如123需要使用ASCII需要三字节保存，直接转为二进制保存只需要一字节。

使用无符号表示法可以解决数字的保存的问题。

无符号表示法不能表示负数，原码【符号加绝对值表示法】可以表示负数，比如：
```
0000 0001 0010 0011 0100 0101 0110 0111 【+0 ~ +7】
1000 1001 1010 1011 1100 1101 1110 1111 【-0 ~ -7】
```

原码表示负数没问题，但是运算时有着极大缺陷，比如：-3 + 2 = 1011 + 0010 = 1101【-5？错误】

原码运算时涉及正负数运算时，需要取反运算，这种操作会极大降低运算幅度。

反码在表示负数的同时，也解决了运算的问题，反码：
```
0000 0001 0010 0011 0100 0101 0110 0111 【+0 ~ +7】
1111 1110 1101 1100 1011 1010 1010 1000 【-0 ~ -7】
```

现在我们再做运算看看：-3 + 2 = 1100 + 0010 = 1110【-1，正确】

不过反码也有一个巨大缺陷，它同时存在两个0【+0，-0】
表面上看只是浪费了一个码点，实际上是一个很严重的问题，因为反码**破坏了系统编码的连续性和一致性**，很直接的一个问题就是溢出时的处理问题。

因为进位的不连续，导致每次进位，都需要将进位向前推一步。想象一个钟表，原本1-12可以表示白天和黑夜24个小时，但是反码这个“钟表”却在12之后加了一位"0"用于表示第二个区隔，这里的"12"和"0"是同一个值，12进1应该就是1，现在却变成了0，需要向前再推一步。

反码这种溢出处理同样进行了额外的操作，使得性能降低。

补码解决了反码的不连续问题，它很直接的将-0给删掉了，补码：
```
0000 0001 0010 0011 0100 0101 0110 0111 【+0 ~ +7】
1111 1110 1101 1100 1011 1010 1010 1000 【-1 ~ -8】
```

运算：-3 + 2 = 1101 + 0010 = 1111【-1，正确】

补码的好处：
1. 保证系统编码的连续性和一致性
2. 简化操作，无论加法和减法都是加法操作【这一点降低了制造的难度和成本】
3. 可以多表示一位数【-8】
