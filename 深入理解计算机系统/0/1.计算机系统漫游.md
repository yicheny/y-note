[TOC]

# 重点内容概括
- 编译过程
- 系统硬件组成
- 高速缓存
- 操作系统管理硬件

# 编译过程
```
#include <stdio.h>

int main()
{
    printf("hello,world\n");
    return 0;
}
```
- 将这段代码复制保存到`hello.c`文件中
- 使用任意编译器，将源文件编译成可执行文件`hello.exe`
- 打开cmd，输入`hello`，回车
如果上述操作正常进行了，那么屏幕上会显示“hello world”字样

现在回顾刚刚的过程，思考计算机是如何运行代码，并最终输出的。

## 计算机是位+上下文
源程序是如何保存在计算机中的？+1<br>
我们编写源程序时，使用`abcd{}...`这一类字符，并没有直接保存在计算机中，这些字符会被转换成不同字节保存在计算机中

什么是字节？+1<br>
8个位被组织成一组被称作字节，一字节是8位模式，或者说8位比特序列

什么是位模式？+1<br>
多个位组成的比特序列就是位模式，有x位便称为x位模式，比如一字节有8个位，字节就是8位模式

什么是比特【位】？+1<br>
位就是0或1

ASCII【美国信息交换标准代码】+1<br>
大部分现在计算机都使用ASCII标准来表示文本字符，这种方式就是用一个唯一的单字节大小的整数值来表示每个字符。
> 其中不可显示的字符33种，可显示字符95种，合计128种，挑战：https://zh.wikipedia.org/wiki/ASCII

文本文件和二进制文件+1<br>
只由ASCII字符构成的文本称为文本文件，其他所有文件都被称作二进制文件。

系统信息的保存+1<br>
`hello.c`文件的保存表现了一个基本思想：系统中的所有信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络传输的数据，都是由一串比特表示的。

如何区分不同数据对象？1<br>
区分不同对象的唯一方法是我们读到这些数据对象时的上下文

上下文？？？

### 豆知识：C语言的起源+10
1969-1973年期间，贝尔实验室的Dennis Ritchie创建了C语言<br>
1989年，ANSI(美国国家标准学会)颁布了ANSI C标准<br>
在ANSI之后，C语言的标准化成为了ISO(国际标准化组织)的工作<br>
ANSI和ISO的标准定义了C语言和一系列函数库，即**C标准库**<br>
C语言的创造者Dennis Ritchie说过：“C语言是古怪的、有缺陷的，但同时也是一个巨大的成功”，C语言为什么如此成功？<br>
- **C语言和Unix操作系统关系密切**
- **C语言小而简单**
- **C语言是为了实践目的设计的**

## 程序编译过程
回到一开始，我们编写了一份c语言代码`hello.c`，这份代码是供人阅读和理解的，作为程序员我们可以看懂，不过实际上计算机是无法直接执行这份源码的。

那么计算机是如何执行源代码的？+3<br>
1. *源代码每条语句都必须被其他程序转换为一系列的低级机器语言指令*（这里很重要，注意，是将源代码转换为低级机器语言指令，和源代码以二进制字节保存是两回事）
2. *指令按照一种被称作**可执行目标程序**的格式打好包，并以二进制形式保存*
> 目标程序也被称作可执行目标文件

在Unix系统上，从源文件到目标文件的转化是由*编译器驱动程序*完成的：
`linux> gcc -a hello hello.c`
> 思考：编译器驱动程序是怎么编写和执行的？

这里，GCC编译器驱动程序读取源程序文件`hello.c`并将它翻译成一个可执行目标文件`hello`，下面我们具体关注下编译过程。

编译过程 挑战+20<br>
`hello.c` => `hello.i` => `hello.s`【文本】 => `hello.o`【二进制】 => `hello.exe`
1. **预处理**：预处理器(cpp)根据以字符#开头的命令，修改原始C程序。比如示例代码中`#include <stdio.h>`命令告诉预处理器读取系统头文件`stdio.h`的内容，并插入到程序文本中，得到了一个新文件，以`i`做扩展名
2. **编译**：编译器(ccl)将文本`hello.i`翻译成文本`hello.s`，它包含了一个汇编语言程序，该程序包含函数`main`的定义
3. **汇编**：汇编器(as)将`hello.s`翻译成机器语言指令，将指令打包成**可重定位目标程序**格式，并将结果保存到`hello.o`文件中。
4. **链接**：链接器(ld)负责将预编译内容合并到`hello.o`中并保存为`hello.exe`（可执行目标文件，简称可执行文件）。比如示例代码中的`printf`函数存在于`printf.o`中，因而需要通过ld将其合并到程序中。

汇编语言的意义+1<br/>
汇编语言为不同高级语言的不同编译器提供了通用的输出语法

了解编译系统工作有什么好处？+3<br>
- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞

# 系统硬件组成
硬件由哪些部分组成？+1<br/>
总线、I/O设备、主存、处理器

1. 总线 +5
- 定义：贯穿整个系统的一组电子管道
- 作用：携带信息字节并负责在各个部件间传递。
- 备注：通常总线被设计成传送定长的字节块，也就是字(word)，字中的字节数（即*字长*）是一个基本的信息参数，在不同系统中不尽相同，目前机器8字节(64位)和4字节(32位)的情况较多

2. I/O设备 +5
- 定义&作用：系统与外部的交互通道
- 常见I/O设备：鼠标、键盘、显示器、磁盘。其中鼠标和键盘作为输入设备，显示器作为输出设备，磁盘中长期存储数据和程序，既能输入也能输出。
- 备注：每个I/O设备都通过一个**控制器**或**适配器**与I/O总线相连。控制器和适配器的区别主要在于封装方式。控制器是I/O设备本身或系统的主印刷电路板上的芯片组，而适配器则是一块插在主板插槽上的卡，两者的作用都是在I/O总线和I/O设备之间传递信息。           

3. 主存 +5
**主存是临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据**
- 从物理上来说，主存是由一组*动态随机存取存储器*(DRAM)芯片组成的
- 从逻辑上来说，存储器是一个线性的字节数组，每个字节有其唯一的地址(数组索引)，这些地址是从零开始的
- 备注：变量相对应的数据项大小是根据类型变化的，由C语言举例，在运行linux的x86-64机器上，short类型的数据需要2个字节，init和float类型需要4个字节，而long和double需要8个字节

4. 处理器 +5
- 定义：中央处理单元(CPU)，简称处理器，是解释（或执行）存储在主存中指令的引擎。
- 备注1：处理器的核心是一个大小为一个字的存储设备——寄存器，称为程序计数器（PC），在任何时刻，PC都指向主存中的某条机器指令（即含有该条指令的地址）

## CPU执行机制
简述CPU执行机制 +1<br>
在系统通电期间，CPU持续不断的执行PC指向的指令（解释指令中的位，执行该指令指示的简单操作），再更新PC使其指向下一条指令

CPU执行简单操作的核心有哪些部分？+3
1. **主存**
2. **寄存器文件**
3. **算数/逻辑单元(ALU)**

寄存器文件是什么？+1<br>
是一个存储设备，由寄存器组成，每个寄存器拥有唯一的名字

CPU可执行的简单操作有哪些？+10
1. **加载**：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容
2. **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容
3. **操作**：将两个寄存器的内容复制到ALU，ALU对两个字做算数运算，并将结果存放到一个寄存器中，以覆盖寄存器中原来的内容
4. **跳转**：从指令本身中抽取一个字，并将这个字复制到寄存器中，已覆盖寄存器中原来的值

# 高速缓存
为何高速缓存如此重要？+2<br>
执行程序时，系统花费了大量时间将信息从一个地方挪到另一个地方。
> 建议分析下hello程序的运行

hello程序的简单分析 +8<br>
- 程序的位置：程序的机器指令最开始在磁盘上；程序加载时，被复制到主存；当处理器运行程序时，指令从主存复制到处理器
- 数据串`hello,world/n`：最开始在磁盘上，然后被复制到主存，最后复制到显示设备上<br/>
从程序员的角度考虑，这些复制都是开销，减慢了程序"核心"的工作，因此程序设计这的一个主要目标就是使这些复制尽可能快的完成

冯·诺伊曼模型组成 +8<br>
- **存储器**：在**计算机处理过程中**用于储存数据和程序
- **输入/输出**：从计算机外部接受数据和程序，输出结果到计算机外部
- **算数逻辑单元_ALU**：用于算数运算和逻辑运算
- **控制单元**：对其他子系统进行操作控制的单元 

存储设备间的速度原则 +2<br>
造价、速度、空间不可并存。一般而言，非同类型设备中空间较小的存储设备要快于空间较大的存储设备，同类型设备速度越快器造价成本越高。

## 高速缓存存储器(简称cache或高速缓存)
高速缓存诞生的原因+1<br>
因为处理器之间与主存之间存在极大的差异。

高速缓存作用+1<br>
作为暂时的集结区域，存放处理器机器可能会需要的信息，相较于主存更小更快

高速缓存级别<br>
高速缓存有L1、L2、L3三个级别，空间依次增大，速度依次递减。

高速缓存技术原理+2<br>
一种名为*静态随机访问存储器(SRAM)*的硬件技术。

# 存储设备形成层次结构
存储器结构层次+2
1. 寄存器
2. L1(SRAM)
3. L2(SRAM)
4. L3(SRAM)
5. 主存(DRAM)
6. 本地磁盘
7. 远程服务器磁盘

存储器结构层次的主要思想 +2<br>
上一层的存储器作为低一层存储器的高速缓存。因此寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存是磁盘的高速缓存，本地磁盘是远程服务器磁盘的高速缓存。

# 操作系统管理硬件

操作系统基本功能 +5
1. 防止硬件被失控的应用程序滥用
2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

操作系统是如何实现两大基本功能的？+2
通过**进程**、**虚拟内存**、**文件**这几个抽象概念

文件、虚拟内存、进程各是对什么的抽象表示？+5
- 文件是对I/O设备的抽象表示
- 虚拟内存是对主存和磁盘I/O设备的抽象表示
- 进程则是对处理器、主存和I/O设备的抽象表示

## 进程
类似hello这样的程序在现代系统上运行时，操作系统会提供一些假象，请说出4种假象 +6
1. 系统上好像只有这个程序在运行
2. 程序看上去是独占的使用处理器、主存和I/O设备
3. 处理器看上去就像在不间断的一条接一条的执行程序的指令
4. 该程序的代码和数据似乎是系统内存中的唯一对象

进程是什么？+5
- **进程**是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用硬件

并发运行是什么？+3
- 一个进程的指令和另一个进程的指令是交错执行的

需要运行的进程数可以多于运行它们的CPU个数吗？+1
- 可以

系统是如何实现并发运行的？+3
- 通过**上下文切换**机制

什么是上下文？+3
- 操作系统保持跟踪进程运行所需的所有状态信息，这种状态，就是上下文

请举例上下文信息包含哪些内容？+2
- PC和寄存器文件的当前值
- 主存的内容

简述上下文切换 +9
- 在任何一个时刻，单处理系统都只能执行一个进程的代码。
- 当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从上次停止的地方开始

叙述shell进程和hello进程的并发运行 +10
1. 最开始，只有shell进程在运行，即等待命令行的输入
2. 当我们让它运行hello程序时，shell通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权转递给操作系统
3. 操作系统保存shell进程的上下文，创建一个新的hello进程及其上下文，然后将其控制权传给hello进程
4. hello进程终止后，操作系统恢复shell进程的上下文

系统是如何管理进程切换的？+3
- 通过系统内核(kernel)管理

系统内核(kernel)是什么？+12
- 内核是操作系统常驻主存的部分
- 当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一个特殊的*系统调用(system call)*指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序
- 内核不是一个独立的进程，它是系统管理全部进程所用的代码和数据结构的集合

## 线程
线程是什么？+5
- 线程是进程的执行单元，一个进程由多个线程组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据

介绍下线程对比进程的优势 +4
- 多线程比多进程更容易共享数据
- 线程比进程更高效，当有多处理器可用的时候，多线程也是一种使得程序可以运行更快的方法

## 虚拟内存
虚拟内存是什么？+8
- 虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占的使用主存
- 每个进程看到的内存都是一致的，称为**虚拟地址空间**

