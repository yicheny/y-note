[TOC]

# 面临的问题
## 1. css覆写
目前`css`防覆写方案是通过`view`类名进行限定。实际中存在以下问题：
### 1.1 开发者开发疏忽+复核者遗漏css代码检查
部分开发者在开发时依旧没有建立起相关意识，没有使用`view`类名进行限定，并且现在因为工作繁忙，review机制尚未完全推行下去。

另一方面，目前并不能保证复核者完遵守这一规范，实际上复核者很有可能遗漏对于css代码的具体检查。

我认为目前对于复核方面的共识亦未完全建立，依靠约定（开发者个人自觉和复核人检查）并不稳定，约定是脆弱的，需要依赖人为控制的部分就有因人为疏忽而引入bug的可能，以目前来说即使违反`view`限定的情况，样式也是有效的，但影响范围不可控制，css的维护成本增加。

### 1.2 对于`view`限定不合理
实际项目中，有人对`view`进行了限定，有的起的类名较短，就一两个字节，容易出现冲突

类名也较长，比如说有人起名`contractManagerTradingInfoDialog`这个类名由五个单词组成，然而依旧有冲突的可能，因为它没有加上模块限定。以期权和互换模块来说，两个模块都存在合约管理页面，如果不加上模块限定就会冲突。

表面上看这里的问题是没有加上模块名字进行限定，不过我认为不仅如此，实际情况会更复杂，这里我们对类名命名并没有一个统一的规范，完全依赖于个人，没有统一规范使得css的维护成本提高。

这种情况会出现类名不统一的情况，比如说假设考虑到需要加类名限定，也有很多不同的部分：
- 限定词不同，不同开发者的限定词可能是不同的，开发者A对互换模块的限定词可能是`swap`，开发者B对互换模块的限定词可能`exchange`。
- 限定词位置亦有可能不同，有的开发者可能是前缀，有的人可能是后缀。
- 词语的连接方式，有的人可能选择驼峰命名，有的人可能选择`-`、`_`、`--`、`__`这些连接符

可以看到，如果要进行统一，要考虑的东西是比较多的，我不认为建立约定是一个好方案，一则这会增加开发者的负担，二则即使建立了共识，通过view限定的方式不可避免的会使类名变得很长。

### 1.3 `Dialog`这类特殊组件
`Dialog`会直接挂载在`body`下，所以不能直接通过`view`类名限制，我们需要直接在类名中体现，
1. 一则名字会变长很多
1. 二则我认为后期类名变更也是个麻烦事，因为如果通过`view`进行限定，如果`view`类名通过约定做到全局唯一，那么理论上是可以统一全局替换的【实际上还是有一定风险】，但是这种硬编码的类名就很难被查找和修改的。有部分情况下，当BA将View的名称和主功能进行调整时，修改View组件名称及其类名是可能的，也是有需要的，不过这种情况相对较少。

## 性能【运行服务 + 部署】
### 编译运行
随着目前项目愈大，编译运行项目的时间逐渐增长，增加了开发成本。

### 部署
部署方面，随着项目变大，部署的时间也变得很长，而且另一个也因此经常出现部署失败。

## 代码管理
目前在代码管理上依旧存在一些问题，主要有两个问题我觉得很难受：

### 公共内容几乎都被放到根目录上
几乎所有的公共组件、hook、utils、class都被放到根目录上，现在这部分公共内容增加速度很快。
1. 一部分文件应该放到模块公共目录上更合适，然而几乎没有模块公共目录
2. 缺少文档，目前公共内容较多，部分开发者对公共部分了解不足，使用程度不够【可以使用公共的但是自己实现了】
3. 增加公共内容没有很好的进行通知，现在公共内容权限是放开的，所有人都可以进行公共内容的开发，一部分人开发后没有进行通知，其他人不知道，那这个公共内容基本只会有开发者一个人使用，失去了公共内容的意义

### 不合理的公共内容引用
比如说我在`option`模块下的某个目录【比如说`option/a/b/common`】下有一个组件`History`，在另一个模块的文件`swap/c/d/view.js`被使用了，这种情况不合理，不应该跨模块进行引用。

即使同模块下也会出现类似的异常引用，比如说`option/a/common`被`option/b/*`、`option/b/*`的组件引用，现在出现了`a`页面整个被重构成`option/newA`，但是却不能直接删除这个废弃目录的情况。

以现在情况为例，废弃`a`页面（这是一个很庞大的页面，涉及数十个文件）的存在，导致很多人找错文件【因为文件和组件名甚至代码一模一样】，会造成修改无效的情况。

还有即使找对了文件，依旧会存在修改无效的情况，比如说有一个`History.scss`文件修改样式，明明修改了对应的样式文件但却出现了修改无效的情况，原因是相同组件类名样式被覆写了。

这种情况并不合理，如果是业务组件就应该加`view`限定【这也是我之前说新组件需要修改`view`类名的原因】，如果是公共组件那就不要放到业务目录下。

# 解决方案
## css覆写
### 方案1 `css modules` 
我认为可以较好的解决原有的问题：
1. 命名可以起的很短
2. 不需要考虑一系列相关的命名问题
3. 对于`Dialog`这类组件也不需要特殊处理
4. 组件改名，不需要调整`css`类名
5. 没有冲突风险

还有一个好处就是几乎0成本迁入，因为scss本身就有这个功能，我们只需要决定是否使用。

另一个之前关于冯老师您考虑的问题：修改`css in module`样式的问题:
//b_colorBlue__1Bt1H (src/b/index.module.scss)
//b_colorBlue__2Jzs2 (src/a/b/index.module.scss)
//src_colorBlue__3Lbnm (src/index.module.scss)

### 方案2 微前端`qiankun`
同样可以解决问题，大体思路是引入组件时按需引入相应的样式表，卸载组件时移除样式表。

缺点是迁移成本较高，需要使用微前端库。

## 性能
### 方案1 MPA 
`MPA` 即为 `multiple page application`【多页面应用模型】

MPA 方案的优点在于 部署简单、各应用之间硬隔离，天生具备技术栈无关、独立开发、独立部署的特性。缺点则也很明显，应用之间切换会造成浏览器重刷，由于产品域名之间相互跳转，流程体验上会存在断点。

使用`MPA`放弃了`SPA`的优势，我不认为这是一个好的方案

[MAP与SPA对比](https://set.sh/post/180804-spa-and-mpa)

### 方案2 微前端`qiankun`
兼具`MPA`和`SPA`优势，可以分开部署和运行，但是通过**路由系统 + 资源加载**进行页面渲染，渲染性能相对较高。

## 代码管理
### 方案1 找时间清理混乱的代码
实行起来比较容易。 不过对于代码管理还是依赖于约定，还是那句话：约定是脆弱的，依赖约定就可能 

# 微前端技术细节【需要考虑的一些问题】
## 请求(携带`token`)

## 应用通信