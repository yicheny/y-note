[TOC]

# 异步处理
推荐做法是使用`redux-thunk`中间件。

`action`创建函数除了可以创建对象之外，还可以创建函数，当返回值是一个函数时，交给`redux-thunk`进行处理，这个返回的函数被称作`thunk`，一般是有副作用的非纯函数。

```js
//创建store前需要添加thunk中间件
const store = createStore(formApp,applyMiddleware(thunkMiddleware));

//reducer和同步写法一致，这里不再重复

//action creator
export function updateComicSentenceCreator(){
    return function thunk(dispatch){
        //这里视情况可以执行dispatch,比如说发起请求的通知
        return axios.get(`http://v1.hitokoto.cn`).then(r=>{
            dispatch({type:UPDATE_COMIC_SENTENCE,comicSentence:r.data})
        }).catch(()=>{
            console.error('v1.hitokoto.cn请求失败！')
        })
    }
}

//mapDispatchToProps
const mapDispatchToProps = (dispatch) => {
    return {
        //必须通过dispatch调用thunk函数
        updateComicSentence:()=>dispatch(updateComicSentenceCreator());
    }
}

//使用
//副作用处理
useEffect(()=>{
    updateComicSentence();
    const timeId = setInterval(updateComicSentence,7000)
    return ()=>clearInterval(timeId);
},[updateComicSentence])

//UI
<div>语句：{comicSentence.hitokoto}---{comicSentence.from}</div>
```

`thunk`并非处理异步的唯一选择：
