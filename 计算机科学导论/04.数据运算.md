[TOC]

# 逻辑运算
## 什么是逻辑运算？
逻辑运算指 那些应用于模式中的一个二进制位，或在两个模式中相应的两个二进制位的相同基本运算。

上面这句话不太容易理解，逻辑运算其实就是 在位/模式层次上 通过逻辑值输入 进行运算 得到逻辑值输出。

什么意思？首先，我们从最基本的位逻辑运算开始理解。

## 位层次的逻辑运算
一个位可能是0或1，假设现在我们定义**0**代表逻辑**假**,定义**1**代表逻辑**真**
> 简记：0假1真

### 逻辑运算算法
现在我们定义四种逻辑运算：非-NOT、与-AND、或-OR、异或-XOR
- NOT：输出值是输入值的相反位。例如：输入0-输出1
- AND: 输入值中有一位为0，则输出值为0。例如：01-0
- OR: 输入值中有一个为1，则输出为1。例如：01-1
- XOR: 输入值全为1或全为0时，返回0。例如：11-0
> 逻辑运算可以输入一位或两位，但输出总是一位。<br/>
> NOT是一元运算符,AND、OR、XOR是二元运算符

## 模式层次的逻辑运算
很简单，就是对位模式中的每一位都进行逻辑运算。其中，NOT运算符只需要一个位模式，而AND、OR、XOR需要两种位数相同的位模式进行运算。例如：
> 一定要理解位模式存储的是数据，数据不只是数字，这一点很重要
```
逻辑运算符：NOT
输入：11110000
输出：00001111

逻辑运算符：AND
输入： 10011000
      00101010
输出：00001000     

逻辑运算符：OR
输入： 10011001
      00101110
输出：10111111

逻辑运算符：XOR
输入： 10011001
      00101110
输出：10110111
```
### 逻辑运算在位模式层次的应用
#### NOT
用于对整个模式进行取反

#### AND
先说一下复位，**复位**就是无论指定原来是什么值，经过逻辑运算后该位的值被设置为0。

一般通过掩码实现复位，很简单，在需要复位的位上设置掩码值为0即可，示例：
```
需求：左边5位需要复位

逻辑运算符：AND
输入：10100110
掩码：00000111
输出：00000110
```

#### OR
先说下置位，**置位**就是无论指定原来是什么值，经过逻辑运算后该位的值被设置为1。
      
通过掩码实现置位，在需要复位的位上设置掩码值为1即可，示例：
```
需求：左边5位需要置位

逻辑运算符：OR
输入：10100110
掩码：11111000
输出：11111110
```

#### XOR
XOR用于使指定的位反转。

通过掩码实现，在需要反转的位上设置掩码值为1即可，示例：
```
需求：左边5位需要位反转

逻辑运算符：XOR
输入：10100110
掩码：11111000
输出：01011110
```

# 移位运算
## 什么是移位运算
移位运算就是 移动模式中的位，改变位的位置的运算。

移位运算分为两大类：逻辑移位运算、算术移位运算

## 逻辑移位运算
因为逻辑移位运算可能会改变数字的符号，所以只能用于不带符号位的位模式。

### 1.逻辑移位
很简单，如果需要实现逻辑左/右移x个位置，则丢弃相应方向的x个位，并在相反方向添加x个0。示例：
```
需求：逻辑左移1位
输入值：10011000
输出值：00110000
```

### 2.循环移位/旋转移位
很简单，如果需要实现循环左/右移x个位，则取出相应方向的x个位，并在相反方向上添加这取出的x个位。示例：
```
需求：循环左移3位
输入值：10011000
输出值：11000100
```

## 算术移位运算
算术移位运算被用于处理 使用二进制补码格式保存的整数。

分别讨论下算术右移和算术左移的情况：
- 算术右移，对整数除以2【向下取整】
- 算术左移，对整数乘以2【可能存在溢出的情况，记住溢出情况下结果是非法的即可】
> 关于判断结果是否非法有个很简单的方法，看符号位和移位前是否一致，不一致就是非法结果

```
需求：算术右移1位
输入值：10011001
运算过程【没有展示转换细节】：
    1. 10011001转换为十进制数字-103
    2. -103除以2并向下取整为-52
    3. -52二进制补码保存为11001100
输出值：11001100

需求：算术左移1位【未溢出】
输入值：11011001
运算过程：
    1. 11011001转换为十进制数字-39
    2. -39乘以2为-78【未溢出】
    3. -78二进制补码保存为10110010
输出值：10110010

需求： 算术左移1位【溢出】
输入值：01111111
运算过程：
    1. 01111111转换为十进制数字127
    2. 127乘以2位254【溢出】
    3. 254二进制补码保存为11111110【非法】
输出值：11111110【非法】
```

### 逻辑运算与逻辑位移运算结合
两者结合位我们提供了操作位模式的工具。示例：
```
需求：判断位模式hgfedcba【每个字母代表对应位的不确定值】的第三位是0还是1
输入：hgfedcba
过程：
    1.逻辑右移两次，使其指定位到达模式最右侧【00hgfedc】
    2.使用AND运算符和掩码00000001进行运算【0000000c】
    3.判断0000000c是无符号的整数1还是0，结果即为指定的值
输出：c的值【0/1】
```

## 算术运算
包括加、减、乘、除等，适用于浮点数和整数。

乘除法的实现较为复杂，所以这里只讨论加、减法的实现，减法可以被转换成加法运算。

## 整数的算术运算
### 二进制补码整数
二进制补码整数的加减法运算较为简单，它的优势在于只需要考虑**运算**的变化。示例:
```
输入值A：00010001
输入值B: 00010110
运算符：+
过程：
    A+B = 00100111
输出：00100111

输入值A：00011000【+24】
输入值B: 11101111【-17】
运算符：-
过程：
    1.获取被减数B的补码值：00010001
    2.减数A加上被减数B的补码值：00011000+00010001=00101001
输出：00101001【+41】
```

### 符号加绝对值整数
关键点在于**运算**和**符号**的变化。

运算过程：
1. 检查运算，如果运算是减法，改变第二个值的符号【简化成两整数的加法】
2. 对两符号应用XOR，如果输出为0，则代表两个数符号相同
3-1. 如果符号相同，符号不变，将两整数的绝对值相加
3-2. 如果符号不同
    - 符号取绝对值大的整数的符号
    - 将减数加上被减数【符号位为1的数】的补码并对其结果进行补码，得到新的绝对值

示例：
```
输入值A:00010001【+17】
输入值B:00010110【+22】
运算符：+
过程：
    1.检查运算，+运算符不做任何改变
    2.对两符号进行XOR运算，0 XOR 0 => 0 【输出为0，两符号相同】
    3.符号相同
        3-1:符号不变，为0
        3-2:将两整数的绝对值相加：0100111
        3-3：连接符号与绝对值：00100111
输出：00100111【+39】

输入值A:00010001【+17】
输入值B:10010110【-22】
运算符：+
过程：
    1. +号不做改变
    2. 0 XOR 1 => 1 
    3. 符号不同
        3-1. 比较两数绝对值大小，B>A，取符号1
        3-2. A加上B的补码值并对其结果进行补码，得到绝对值：0000101
        3-3. 连接符号与绝对值：10000101
输出：10000101【-5】

输入值A：11010001【-81】
输入值B: 10010110【-22】
运算符：-
过程：
    1. -号则B符号位改变【00010110】
    2. 1 XOR 0 => 1
    3. 符号不同
        3-1. 比较绝对值大小，A>B，取符号1
        3-2. B加上A的补码值并对其结果进行补码，得到绝对值： 0111011
        3-3. 连接符号与绝对值：10111011
输出：10111011【-59】                      
```

## 实数的算术运算
运算流程：
1. 如果两数任一个为0，则结果为另一个数，过程终止
2. 检查运算：如果运算是减法，改变第二个值的符号【简化成加法】
3. 去规范化：通过在尾数中包含隐含的1和增加指数
4. 统一指数：增加较小的指数，移位相应的尾数，直到两个数具有相同的指数
5. 将组合后的数当作符号加绝对值格式的整数，并进行运算
6. 将所得结果规范化

示例：
```
输入值A: 0 10000001 01110000000000000000000【+5.75】
输入值B: 0 10000110 01000011110000000000000【+161.875】
运算符：+ 
过程：
    1. 两数均不为0，通过
    2. +号不做改变
    3. 
```
