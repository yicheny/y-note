[TOC]

# 数据类型
计算机现在可以执行多种类型的任务：算术运算、文字编辑、图片处理、视频播放、录制音频等等不一而足，不同类型的任务需要使用不同类型的数据。

在计算机科学中，使用**多媒体**一词描述包含数字、文字、图像、音频、视频等信息

在计算机内部，所有的外部信息都会被转换成位模式存储。

## 位
**位（bit，binary digit）是计算机存储的最小单位**，它是0或1。

**位模式，也叫位流，是由多个位组成的序列**，例如`10101111`就是8个位组成的位模式。
> 长度为8的位模式被称作1个字节

# 存储数字
数字在存储到计算机前会被转换为二进制，首先有两个问题需要解决：
- 如何存储数字的正负号？
- 如何显示十进制的小数点？

目前有两种存储方案：定点和浮点。

```
|- 定点表示法_存储整数
    |- 1.无符号表示法
    |- 2.符号加绝对值表示法
    |- 3.二进制补码表示法
|- 浮点表示法_存储实数
    |- 浮点表示法
```

## 定点表示法_存储整数
定点表示法用于存储整数，定点表示法没有小数部分。

### 1.无符号表示法
只用于存储没有符号的整数，理想是0到无穷大之间，不过计算机会分配n位用于定义最大无符号整数常量，这个最大常量即为`(2^n)-1`

存储无符号整数步骤如下：
- 转换为二进制
- 如果转换后的二进制数不满n位，则在左边补0，使得总位数为n (如果溢出则只保存最右边的n位数字)

示例：
```
将7存储在 8位存储单元中：
1. 转换为二进制111
2. 补足位数，得到00000111
3. 存储00000111
```

#### 溢出
```
将十进制数20存储到 4位存储单元中：
1. 转换为二进制 10100
2. 溢出：只保存最右边的4位，得到0100
3. 存储0100
```

#### 无符号表示法的应用
无符号表示可以提高存储的效率，因为不必存储整数符号，所有的位都可以用于存储数字。

常用场景如下：
- **计数**：从0或1开始增长
- **寻址**：一些计算机语言中，存储单元会存储另一个存储单元的地址，这个地址也是使用无符号表示法存储的
- **其他数据存储**：其他数据类型比如文本、图像、音频、视频等，都是通过无符号表示法存储的

### 2.符号加绝对值表示法
与无符号表示法的区别在于会有一位用于存储符号，相同位数的情况下，符号加绝对值表示法所能表达的最大值只有无符号表示法最大值的一半`2^(n-1) -1`。

另外需要注意的是，这种表示法下，正0和负0实际保存并不相同。

存储整数步骤如下：
- 转换为二进制
- 如果转换后的二进制数不满n-1位，则在左边补0，使得总位数为n-1位
- 加符号位：在最左边补0或1【0为正，1为负】
- 溢出处理
```
将十进制数-28存储在 8位存储单元：
1. 转换位二进制数： 11100
2. 补零：0011100
3. 加符号位：10011100
4. 存储10011100 
```

#### 溢出
符号加绝对值表示法有正负两种溢出的情况，需要分别对待：这里暂时不太理解，待后续补充...

#### 符号加绝对值表示法的应用
- 通常用于采样模拟信号，比如音频
- 不用于存储整数，而是用于存储实数，后续会提到

### 3.二进制补码表示法
几乎所有计算机在存储有符号整数时使用的都是二进制补码表示法。

这个方法将整数分为两个相等的子范围，首位【最左位】为0表示正数，首位为1表示负数，见示例：
```
000 001 010 011 100 101 110 111
 0   1   2   3  -4  -3  -2  -1
 
或者也可以这么看：
100 101 110 111 000 001 010 011 
-4  -3  -2  -1   0   1   2   3
```

下面介绍两种运算方法：反码、补码

#### 反码
很简单，将位模式里的所有位中的1变为0，0变为1，示例：
```
原位模式： 00110110
反码运算： 11001001
```
#### 补码
两步：
1. 从右向左复制位，直到第一次复制1
2. 其余【左侧】没有被复制的位进行反转

补码示例：
```
原位模式： 00110100
补码运算： 11001100
```

了解了这两种运算之后，现在说一下二进制补码表示法式如何存储整数的：

#### 二进制补码存储整数
三步：
1. 转换为2进制
2. 补位
3. 如果整数是正数或0，则原样存储；如果是负数则取其补码存储

存储示例：
```
将十进制数28存储到 8位存储单元
1.转换为二进制： 11100
2.补位： 00011100
3.正数原样存储： 存储00011100

将十进制数-28存储到 8位存储单元
1.转换为二进制： 11100
2.补位： 00011100
3.负数补码存储： 存储11100100
```

#### 二进制补码还原整数【十进制】
两步：
1. 首位为1，取补码；首位为0，不操作
2. 将得到的二进制整数转换为十进制
3. 加上符号

还原示例：
```
将存储在8位存储单元的00001101还原成十进制整数
1. 首位为0，不操作： 00001101
2. 二进制转换： 13
3. 加上符号【可选】：+ 13

将存储在8位存储单元的11100110还原成十进制整数
1. 首位为1，取补码：00011010
2. 十进制转换： 26
3. 加上符号： -26
```

#### 二进制补码表示法的溢出
和符号加绝对值表示法的溢出处理相同。

#### 二进制补码表示法的应用
如今，二进制补码表示法是计算机存储整数的标准表示法，它会为运算带来很大简便，之后会介绍这一点

## 浮点表示法_存储实数
**实数是带有整数部分和小数部分的数字**,计算机中不使用定点表示法存储实数，因为有精度受损的情况。

为了维持正确度或精度，计算机中存储实数使用的是浮点表示法

### 浮点表示法的构成
三部分：
- 符号： 0或1
- 指数：定义小数点移动的位数，使用余码表示法存储【因为位移可以为负】
- 尾数：定义了数字的精度【**注意，尾数是用无符号表示法存储的，但是补零在右侧**】
> 指数 = 位移量 + 余码

关于浮点数表示法，必须先提到科学计数法：
```
十进制数： + 7 425 000 000 000 000 000.00
科学计数法：+ 7.425 * (10^21)

十进制数： - 0.000 000 000 000 023 2
科学计数法： - 2.32 * (10^-14) 
```
科学计数法的好处就是写起来更短更省空间，很明显。

注意，为了使表示法的固定部分统一，科学计数法和浮点表示法都在小数点左边使用了唯一的非0标识，这被称作规范化，示例：
```
十进制  d.xxxxxxxxxxx 注意：d是1到9，x是0到9
二进制  1.yyyyyyyyyyy 注意：y是0或1
```

二进制数规范化后，我们只需要保存3部分信息：符号、指数、尾数，示例
```
原二进制数： + 1000111.0101
转换位科学计数法： + 2^6 * 1.0001110101
保存信息： +【符号】 6【指数】 0001110101【尾数】

注意：尾数保存时1.并没有被存储，它们是隐含的
```

#### 余码表示法/偏移表示法
> 浮点表示法中的指数存储使用的就是余码表示法

所谓余码表示法，就是保留无符号整数，然后选择一个整数作为偏移量。大于偏移量的即为正，小于偏移量的即为负。选择偏移量为x，则被称作余x码。

一般我们选择的偏移量是2^(n-1) -1 【可以想象是将所有数劈成两半，然后选取偏向左边的中间数】

##### 余码表示法存储步骤【3步】：
1. 转换二进制
2. 转换数加上偏移量【二进制】
3. 补位

不过人类对于二进制处理并不是那么敏锐，我们人类进行存储推算是可以这样：
1. 原数加上偏移量【十进制】
2. 转换二进制
3. 补位 
这样存储的结果不变，不过对于人类来说更容易进行计算，这里的计算是十进制而非二进制，更方便计算。

示例：
```
注：以下偏移量均为127【1 111 111】

将十进制数6存储到 8位存储单元【计算机实际存储】：
1. 转换二进制： 110
2. 加上偏移量： 110+1111111=10000101
3. 补位： 10000101
4. 存储

将十进制数-36存储到 8位存储单元【人脑推算】：
1. 加上偏移量： -36+127=91
2. 转换二进制： 1011011
3. 补位： 01011011
4. 存储
```

#### IEEE标准
IEEE【电子和电器工程师协会】定义了几种存储浮点数的标准，使用的比较多的是单精度和双精度两种，下面介绍下。

##### 单精度
符号1位，指数8位【偏移量127】，尾数23位，共计32位

##### 双精度
符号1位，指数11位【偏移量1023】，尾数52位，共计64位

#### IEEE标准浮点数的存储步骤【5步】
> 以下S代表符号，E代表指数，M代表尾数
1. 找到符号S【0/1】
2. 数字转换为二进制
3. 规范化【科学计数法】
4. 指数E 【余码表示法】
5. 尾数M 【右侧补零】
6. 连接S、E、M
> 注意，存储特例0时这三个【S、E、M】约定都设置为0

```
十进制数5.75 的单精度存储
1. 符号： 0
2. 转二进制： 101.11
3. 规范化： 1.0111 * 2E2
4. 指数：2+127=129【十进制】=>10000001【二进制】
5. 尾数：0111=>01110000000000000000000【右边补零】
6. 连接：0 10000001 10110000000000000000000

十进制数-161.875的单精度存储
1. 符号： 1
2. 转二进制： 10100001.111
3. 规范化： 1.0100001111 * 2E7
4. 指数：7+127=134 => 10000110
5. 尾数：0100001111 => 01000011110000000000000
5. 连接：1 10000110 01000011110000000000000

十进制数-0.0234375的单精度存储
1. 符号： 1
2. 转二进制： 0.0000011
3. 规范化： 1.1 * 2E6
4. 指数：-6+127=121 => 01111001
5. 尾数：10000000000000000000000
5. 连接：1 01111001 10000000000000000000000
```

#### IEEE标准浮点数的还原步骤【5步】
1. 符号
2. 位移量【E-127】
3. 去规范
4. 转十进制
5. 连接符号与绝对值

```
将单精度数11 001 010 000 000 000 111 000 100 001 111还原：
1. 符号： 1=> 符号
2. 位移量： 10010100 - 127 = 148-121 = 21
3. 尾数去规范：1.00 000 000 111 000 100 001 111 * 2E21 = 100 000 000 111 000 100 001 1.11
4. 转十进制： 2104378.75
5. 连接： -2104378.75
```

#### 溢出处理
...待完善

#### 截断误差
浮点表示法存储实数可能存在误差，比如说需要存储的尾数由30位，单精度表示法只能存储左边的23位，右边的7位被截断了，还原后的数字会与原数值不同这种情况被称作截断误差。

某些情况下需要用到更精确的大数字或极小数字，为此IEEE定义了一些更大尾数的表示法，这里注意一下。

# 存储文本
位模式存储符号，比如4位存储单元的情况下我们可以这样存储符号：0000-A,0001-B,0010-C......

关键的问题在于，我们用于存储符号的位模式究竟需要多少位？——这取决于语言集中一共由多少个不同的符号。

比如说，如果只需要存储小写英文字母，那么只需要提供可以存储26个不同符号的位模式就够了，如果存储中文，需要的位则会多很多。

不同的位模式集合被设计用于表示文本符号。每一个集合称为**代码**，表示符号的过程被称为**编码**

## 常用代码
### ASCII【美国信息交换标准码】
ANSI【美国国家标准协会】开发，被称为美国信息交换标准码【ASCII】。

ASCII码使用七位的位模式，该代码可以定义2^7=128符号。

如今，ASCII是Unicode的一部分

### Unicode
硬件和软件制造商共同设计，最大可以定义2^32=4 294 976 296【四十二亿九千四百九十七万六千二百九十六】

Unicode的不同部分被分配用于表示世界不同语言的符号，其中还有部分用于表示图形和特殊符号

### 其他编码
有一些国家语言特定的代码，比如中文符号集、日语符号集，不过鉴于Unicode的优势，编码一般都会使用Unicode，这些代码属于小众。

# 存储音频
音频的特点在于不可计数，文本中的文字可以计数，音频是不可计数的。

音频是随时间变化的实体，我们只能在每一时刻度量声音的密度，计算机上的存储音频，实际是存储一个音频信号的密度。

音频是模拟数据的例子。即使我们可以在一段时间内度量所有的值，也不可能将它全部存在计算机内存中，这需要无限数量的内存单元。

## 采样
虽然我们不能采集一段间隔的音频的所有值，不过记录其中一些还是可以的。

**在模拟信号上选取数量有限的点来度量它们的值并记录 这一行为被称作采样**

### 采样率
**采样率是每秒采取样本的数量**

样本数量依赖于模拟信号**变化的最大数量**，信号平坦所需样本就少，信号剧烈所需样本就多。

### 量化
从每个样本测量得到的值是数字，采样率40000意味着我们每秒需要存储40000个值

**量化是指将样本的指截取位最接近的整数值的过程**【因为无法号表示法用于存储整数，所以样本值需要截取，比如17.2截取为17，17.8截取为18】

### 编码
量化得到的样本值需要被编码成位模式存储，有两种情况：
- 某些系统为样本赋正值或负值，这种情况需要使用符号加绝对值表示法存储
- 某些系统只需要赋正值，则使用无符号表示法存储

#### 每样本位
**对于每个样本系统需要决定分配多少位**，过去只有8位，现在8、16、32也是常见的。

每样本位的数量被称作**位深度**【分配的位数】

#### 位率
将位深度设为B，采样率设为S，则R=B*S，该乘积被称作**位率**

例如：40000 * 16 = 640 000 b/s = 640KB/s

#### 声音编码标准
目前音频编码主流标准式MP3【MPEG layer3简写】，mp3标准是用于视频压缩方法的MPEG【运动图像专家组】标准的修改版。

mp3是先使用 44100 * 16 = 705 600 b/s 的位率标准采集存储样本，再进行压缩。

mp3的压缩是有损压缩法，压缩具体见15章

# 存储图像
两种技术：光栅图、矢量图

## 光栅图【位图】
存储模拟图像【如照片】使用的是光栅图。

一张照片由模拟数据组成，这点类似音频，不同的是数据密度【色彩】因空间变化而不因时间变化。

图像模拟数据同样需要采样，图像的采样被称作**扫描**,样本被称作**像素**。

### 解析度
和音频种的采样率类似，**图像扫描时需要决定每英寸的方块或线条需要记录的像素数量**——图像处理时的扫描率被称作解析度

如果解析度足够高，人眼不会看出图像的不连续

### 色彩深度
和音频的位深度类似，**存储/表示像素的位的数量被称作色彩深度**

对颜色的感觉时人类眼睛对于光线的响应，眼睛由不同类型的感光细胞，一些响应红、黄、蓝三原色【RGB】，而另一些用于响应光的密度

#### 真彩色
像素编码技术之一，使用24位来编码一个像素，该技术中每种颜色都由0到255之间的三位数字表示，所以三原色【RGB】都表示为8位。

真彩色技术可以编码2^24 = 16 777 216 【一千六百七十七万七千二百一十六】

#### 索引色【调色板色】
真彩色可以使用超过1600万种颜色，实际很多应用程序不需要使用如此大的颜色范围。

索引色模式则是建立一个大的色彩集【通常时常用颜色组成的256种】，每种颜色对应0-255的一个值，我们通过对应的索引即可获取对应或相近的颜色。

索引色模式使用的8位的位模式存储颜色。

### 图像编码标准
主要有以下几种图像编码标准再使用：
- JPEG使用真彩色模式
- GIF使用索引色模式

## 矢量图
光栅图有两个缺点:文件尺寸太大、调整图像大小会有麻烦【放大图像意味着解析度变小】

矢量图的编码并不存储每个像素的位模式，它是将一个图像分解成几何图形的组合，例如：线段、矩形、圆形等...

每个几何形状由数学公式表达，比如：线段由端点的坐标描述，圆由圆心坐标和半径长度来描述。

**矢量图是由定义绘制几何形状的一系列命令构成的**

需要显示或打印图像时，将图像的尺寸输入系统，系统会按尺寸设计图像大小并利用公式画出图像。这种情况狂下，每一次绘制图像，公式将会被重新计算一次，因此，矢量图也被叫做**几何模型**或**面向对象图形**

示例：
```
画一个半径为r的圆形，程序绘制圆形所需信息如下：
1. 半径
2. 圆形坐标
3. 绘制的线型和颜色
4. 填充的类型和颜色

当改变圆形的大小时，程序会改变半径值然后重新计算并绘制
```

矢量图不适合存储细微精妙的图像，比如照片。

矢量图适合应用程序采用主要的几何元素来创建图像，比如Flash、PostScript、TrueType、CAD等使用了矢量图进行工程绘图

# 存储视频
**图像在时间上的表示，称为帧**，帧连续的播放就会形成动态的视频

换句话说，**视频时随空间(单个图像)和时间(一系列图像)变化的信息表现**
> 注意，视频并不包含音频，它是图像在时间上的组合

知道如何存储图像，也就知道如何存储视频，因为图像组合起来就是视频。

现在的视频通常是被压缩的，关于压缩，见15章。

# 问题
- 计算机存储时是如何区分不同类型的信息的【比如说0000可以表示文字A，也可以表示一个音频样本】——答案是读取数据时的上下文